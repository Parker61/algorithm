# факториал

# В математике факториал числа 0 определяется как 1 (0! = 1 по определению). Это соглашение используется в различных
# областях математики и является основой для правильной работы многих математических формул и функций.Если в вашей
# функции оставить условие if n == 1: и не включить обработку случая n == 0, то вызов factorial(0) приведет к
# бесконечной рекурсии, потому что функция будет постоянно вызывать саму себя с уменьшающимся значением n и никогда не
# достигнет условия завершения рекурсии. Это приведет к ошибке переполнения стека вызовов (stack overflow).
# С другой стороны, если правильно обработать случай с n==0, как в вашем первоначальном варианте функции
# (с if n == 0 or n == 1:), то функция корректно возвращает значение 1 для factorial(0), и рекурсия будет
# завершена должным образом для всех неотрицательных целых чисел n.

def factorial(n):
    if n == 1 or n == 0:  # Базовый случай: 0! = 1 и 1! = 1
        return 1
    else:  # Рекурсивный случай: n! = n * (n-1)!
        return n * factorial(n - 1)


number = 5
result = factorial(number)
print(f"Факториал числа {number} равен {result}")  # 120
################################
import math

print(factorial(5))
################################
num = 5
fact = 1
while num > 0:
    fact = fact * num
    num -= 1
print(fact)
################################
num = 5
f = 1
for i in range(2, num + 1):
    f *= i
print(f)


################################
################################
# числа Фибоначчи

def fibonacci_recursive(n):
    if n <= 1:
        return n
    else:
        return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)


# n=5 [0, 1, 1, 2, 3, 5]

# Этот метод приводит к экспоненциальному росту времени выполнения из-за повторных вычислений одних и тех же чисел
# Фибоначчи. Поэтому он неэффективен для больших значений n.
#
# С использованием динамического программирования и мемоизации:

def fibonacci_memoization(n, memo={}):
    if n <= 1:
        return n
    if n not in memo:
        memo[n] = fibonacci_memoization(n - 1, memo) + fibonacci_memoization(n - 2, memo)
    return memo[n]


# В этом подходе используется словарь memo, в котором сохраняются ранее вычисленные значения, чтобы избежать повторных
# вычислений. Это значительно улучшает производительность для больших значений n.
#
# С использованием цикла:

def fibonacci_iterative(n):
    if n <= 1:
        return n
    fib = [0, 1]
    for i in range(2, n + 1):
        fib.append(fib[-1] + fib[-2])
    return fib[n]


# В этом методе используется цикл, чтобы последовательно вычислять числа Фибоначчи. Он эффективен и использует
# только O(n) операций.
#
# Оптимизированный метод с использованием формулы Бине:

import math


def fibonacci_binet(n):
    sqrt_5 = math.sqrt(5)
    phi = (1 + sqrt_5) / 2
    return int((phi ** n - (-phi) ** (-n)) / sqrt_5)


# Этот метод основан на формуле Бине для чисел Фибоначчи и позволяет получить ответ непосредственно без необходимости
# выполнять циклы или рекурсию. Следует отметить, что точность вычислений с плавающей точкой может быть ограничена для
# больших значений n.
print(fibonacci_iterative(5))

prew = cur = 1
element = 5
for n in range(element - 2):
    # tmp = prew + cur
    # prew = cur
    # cur = tmp
    prew, cur = cur, cur + prew
print(str(element) + ' элемент последовательности равен ' + str(cur))  # 5


################################################################
def fibonacci(n):
    prev, cur = 0, 1
    for i in range(n + 1):
        yield prev
        prev, cur = cur, cur + prev


print(*fibonacci(5))


################################################################
def fibonacci():
    prev, cur = 0, 1
    while True:
        yield prev
        prev, cur = cur, prev + cur


gen = fibonacci()
for _ in range(5 + 1):
    print(next(gen))


################################################################
# рекурсия________________________
# возведение числа x в степень y
def degree(x, y):
    if y == 0:
        return 1
    if y == 1:
        return x
    # оставшиеся кейсы, когда степень > 1
    if (y != 1):
        return (x * degree(x, y - 1))


x = int(input("Введите число: "))
y = int(input("Введите его степень: "))
print("Результат возведения в степень равен:", degree(x, y))


################################
# подсчёт длины коллекции
def length(collection):
    if not collection:
        return 0
    return 1 + length(collection[1:])


n = [1, 2, 3, 4, 5]
print("Длина коллекции равна: ")
print(length(n))


# Создание счётчика — начинается с 1 и рекурсивно прибавляется к ней ещё по 1, что постепенно отрезает от коллекции по
# одному элементу. Это делается с помощью среза коллекции collection[1:].
################################################################
# Ханойские башни
def move(n, start, finish):
    if n == 1:
        print("Перенести диск 1 со стержня", start, "на стержень", finish)
    else:
        temp = (6 - start) - finish
        move(n - 1, start, temp)
        print("Перенести диск", n, "со стержня", start, "на стержень", finish)
        res = (n - 1, temp, finish)
        print(res)

        return res
################################################################