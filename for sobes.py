# факториал

# В математике факториал числа 0 определяется как 1 (0! = 1 по определению). Это соглашение используется в различных
# областях математики и является основой для правильной работы многих математических формул и функций.Если в вашей
# функции оставить условие if n == 1: и не включить обработку случая n == 0, то вызов factorial(0) приведет к
# бесконечной рекурсии, потому что функция будет постоянно вызывать саму себя с уменьшающимся значением n и никогда не
# достигнет условия завершения рекурсии. Это приведет к ошибке переполнения стека вызовов (stack overflow).
# С другой стороны, если правильно обработать случай с n==0, как в вашем первоначальном варианте функции
# (с if n == 0 or n == 1:), то функция корректно возвращает значение 1 для factorial(0), и рекурсия будет
# завершена должным образом для всех неотрицательных целых чисел n.

def factorial(n):
    if n == 1 or n == 0:  # Базовый случай: 0! = 1 и 1! = 1
        return 1
    else:  # Рекурсивный случай: n! = n * (n-1)!
        return n * factorial(n - 1)


number = 5
result = factorial(number)
print(f"Факториал числа {number} равен {result}")  # 120
################################
import math

print(factorial(5))
################################
num = 5
fact = 1
while num > 0:
    fact = fact * num
    num -= 1
print(fact)
################################
num = 5
f = 1
for i in range(2, num + 1):
    f *= i
print(f)


################################
################################
# числа Фибоначчи

def fibonacci_recursive(n):
    if n <= 1:
        return n
    else:
        return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)


# n=5 [0, 1, 1, 2, 3, 5]

# Этот метод приводит к экспоненциальному росту времени выполнения из-за повторных вычислений одних и тех же чисел
# Фибоначчи. Поэтому он неэффективен для больших значений n.
#
# С использованием динамического программирования и мемоизации:

def fibonacci_memoization(n, memo={}):
    if n <= 1:
        return n
    if n not in memo:
        memo[n] = fibonacci_memoization(n - 1, memo) + fibonacci_memoization(n - 2, memo)
    return memo[n]


# В этом подходе используется словарь memo, в котором сохраняются ранее вычисленные значения, чтобы избежать повторных
# вычислений. Это значительно улучшает производительность для больших значений n.
#
# С использованием цикла:

def fibonacci_iterative(n):
    if n <= 1:
        return n
    fib = [0, 1]
    for i in range(2, n + 1):
        fib.append(fib[-1] + fib[-2])
    return fib[n]


# В этом методе используется цикл, чтобы последовательно вычислять числа Фибоначчи. Он эффективен и использует
# только O(n) операций.
#
# Оптимизированный метод с использованием формулы Бине:

import math


def fibonacci_binet(n):
    sqrt_5 = math.sqrt(5)
    phi = (1 + sqrt_5) / 2
    return int((phi ** n - (-phi) ** (-n)) / sqrt_5)


# Этот метод основан на формуле Бине для чисел Фибоначчи и позволяет получить ответ непосредственно без необходимости
# выполнять циклы или рекурсию. Следует отметить, что точность вычислений с плавающей точкой может быть ограничена для
# больших значений n.
print(fibonacci_iterative(5))

prew = cur = 1
element = 5
for n in range(element - 2):
    # tmp = prew + cur
    # prew = cur
    # cur = tmp
    prew, cur = cur, cur + prew
print(str(element) + ' элемент последовательности равен ' + str(cur))  # 5
################################################################
def fibonacci(n):
    prev, cur = 0, 1
    for i in range(n + 1):
        yield prev
        prev, cur = cur, cur + prev


print(*fibonacci(5))
################################################################
def fibonacci():
    prev, cur = 0, 1
    while True:
        yield prev
        prev, cur = cur, prev + cur


gen=fibonacci()
for _ in range(5+1):
    print(next(gen))
################################################################
р




























