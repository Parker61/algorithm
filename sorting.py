#
# ____________ сортировка пузырьком bubble sort_____________ O(n^2)
# В этом примере функция bubble_sort() принимает список arr и сортирует его по возрастанию, используя алгоритм
# сортировки пузырьком. Она проходит по элементам массива и сравнивает каждую пару соседних элементов, меняя их местами,
# если требуется. Повторяя этот процесс несколько раз, наибольший элемент "всплывает" на последнюю позицию.
def bubble_sort(arr):
    for i in range(len(arr) - 1):  # Проходим по всем элементам массива
        # Последние i элементов уже отсортированы,
        # поэтому мы можем их игнорировать во время прохода ->len(arr) - 1 -i
        for j in range(len(arr) - 1 - i):
            if arr[j] > arr[j + 1]:  # Проверяем, нужно ли менять местами элементы
                arr[j], arr[j + 1] = arr[j + 1], arr[j]


array = [5, 2, 9, 1, 3]
bubble_sort(array)
print(array)  # Выводит: [1, 2, 3, 5, 9]


################################################################
# Алгоритм сортировки пузырьком (bubble sort) работает следующим образом:
# Повторять следующие шаги, пока список не будет отсортирован:
# Проходить по списку сравнивая пары соседних элементов.
# Если элементы стоят в неправильном порядке, менять их местами. Если во время прохода по списку не было совершено ни
# одной замены элементов, то список уже отсортирован и алгоритм  можно завершить.


def bubble_sort(arr):
    n = len(arr)
    # Повторяем n-1 раз, где n - длина списка
    for i in range(n - 1):
        swapped = False  # Флаг для отслеживания замен в текущем проходе
        # Проходим по списку до n-i-1, т.к. после каждого прохода
        # самый большой элемент всплывает в конец
        for j in range(n - i - 1):
            # Если текущий элемент больше следующего, меняем их местами
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        # Если в текущем проходе не было замен, то список уже отсортирован
        if not swapped:
            break
    return arr


arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = bubble_sort(arr)
print("Отсортированный список:", sorted_arr)  # [11, 12, 22, 25, 34, 64, 90]


########################################################
# сортировка пузырьком от O(n^2) до O(n) / memory O(1)
def mySort(array):
    noSorted = True
    while noSorted:
        noSorted = False
        for i in range(0, len(array) - 1):
            if (array[i] > array[i + 1]):
                noSorted = True
                array[i], array[i + 1] = array[i + 1], array[i]
    return array


a = [7, 5, 3, 1, 4, 9, 3, 2]
print(mySort(a))


################################
# _Шейкерная сортировка, также известная как сортировка по методу перемешивания или шейкерная сортировка с отбрасыванием
# (cocktail sort), является разновидностью пузырьковой сортировки. Она эффективна, когда элементы массива могут
# существенно отклоняться от своей конечной позиции.Алгоритм шейкерной сортировки работает следующим образом:
# Инициализируйте переменные left и right со значениями 0 и n-1 соответственно, где n - это количество элементов в
# массиве.Повторяйте следующие шаги, пока left меньше right: Проходите по массиву с помощью цикла от left до right.
# Если текущий элемент больше следующего элемента, меняйте их местами.Уменьшите значение right на 1.
# Проходите по массиву с помощью цикла от right до left. Если текущий элемент меньше предыдущего элемента, меняйте
# их местами.Увеличьте значение left на 1.Когда left станет больше или равным right, массив будет отсортирован по
# возрастанию.Этот алгоритм выполняет проходы от начала массива к концу и обратно, как движение шейкера, отсюда и
# название. Это позволяет эффективно обрабатывать случаи, когда большинство элементов уже находятся близко к своим
# конечным позициям, поэтому они не нуждаются в операциях перемещения. от O(n^2) до O(n) / memory O(1)

def shaker_sort(arr):
    left = 0
    right = len(arr) - 1

    while left < right:
        for i in range(left, right):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]

        right -= 1

        for i in range(right, left, -1):
            if arr[i] < arr[i - 1]:
                arr[i], arr[i - 1] = arr[i - 1], arr[i]

        left += 1

    return arr


array = [5, 3, 2, 1, 9, 4, 7, 6]
sorted_array = shaker_sort(array)
print(sorted_array)


################################################################№
# алгоритм "сортировки ________расчёской": от O(n^2) до O(nlogn) / memory O(1)
# Основной алгоритм сортировки расчёской работает следующим образом:
# Задается начальное значение разрыва (gap), равное длине массива.
# На каждой итерации значение разрыва уменьшается на коэффициент сжатия (в данном случае 1.3), пока оно не достигнет
# значения 1. Происходит проход по массиву: сравниваются элементы на расстоянии gap и, если они находятся
# в неправильном порядке, меняются местами. Если на одной итерации не было совершено ни одной перестановки элементов,
# считается, что массив отсортирован.
def comb_sort(arr):
    n = len(arr)
    gap = n
    shrink = 1.3
    sorted = False

    while not sorted:
        gap = int(gap / shrink)
        if gap <= 1:
            gap = 1
            sorted = True

        i = 0
        while i + gap < n:
            if arr[i] > arr[i + gap]:
                arr[i], arr[i + gap] = arr[i + gap], arr[i]
                sorted = False
            i += 1

    return arr


################################№№№№№№№№№№№###########################
################################
# Алгоритм сортировки ___вставками
for i in range(1, N):  # старт со 2-го эл
    for j in range(i, 0, -1):  # обход с права на лево последовательно с конца эл = i
        if a[j] < a[j - 1]:
            a[j], a[j - 1] = a[j - 1], a[j]  # меняем местами
        else:
            break  # дошли до конца по j и перемещаемся далее по i


###################################
# Алгоритм сортировки вставками заключается в том, чтобы перебирать элементы входного массива и вставлять каждый элемент
# на свое место в уже отсортированной части массива. То есть, на каждой итерации мы берем очередной элемент и ищем
# правильное место для его вставки в уже отсортированную часть массива.
# Суть сортировки
# Перебираются элементы в неотсортированной части массива.
# Каждый элемент вставляется в отсортированную часть массива на то место, где он должен находиться.

def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key


arr = [5, 2, 8, 12, 3]
insertion_sort(arr)
print(arr)


################################
# Сортировка ___выбором (Selection sort) является простым алгоритмом сортировки, который состоит из повторения следующих
# шагов: находим наименьший (или наибольший) элемент из неотсортированной части массива и помещаем его в начало
# (или конец) отсортированной части массива. Этот процесс повторяется до тех пор, пока весь массив не будет отсортирован.

def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i  # промежуточная переменная
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]  # обмен значениями с промежуточной переменной
    return arr


################################
# ############################################### #################
# # Быстрая сортировка quicksort" Хоара через рекурсию
# "quicksort" представляет рекурсивный алгоритм быстрой сортировки (quicksort). Она работает следующим образом:
# Базовый случай: если длина массива равна 0 или 1, то он уже отсортирован, поэтому просто возвращается исходный массив.
# В противном случае, выбирается опорный элемент (pivot) из массива.
# Создаются два подмассива: less (содержащий элементы меньшие или равные опорному) и greater (содержащий элементы
# большие опорного). Затем рекурсивно вызывается quicksort для подмассивов less и greater.
# Возвращается конкатенация отсортированных подмассивов less, опорного элемента pivot и отсортированного подмассива greater.

l = [4, 5, 6, -1, -7, -9, 7]


def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    elem = arr[0]  # точка опоры pivot с начала списка
    left = list(filter(lambda x: x < elem, arr))
    center = [i for i in arr if i == elem]
    right = list(filter(lambda x: x > elem, arr))

    return quick_sort(left) + center + quick_sort(right)


print(quick_sort(l))


################################################################
# 2.
# Вторая функция "Partition" используется внутри "QuickSortImpl" для разделения массива на подмассивы с элементами,
# меньшими и большими опорного элемента. Она работает следующим образом:Выбирается опорный элемент (x) из массива values.
# Задается начальный индекс less для подмассива, содержащего элементы меньшие или равные опорному элементу.
# Проходится циклом по массиву values от l до r (не включая r).Если значение текущего элемента values[i] меньше или
# равно опорному элементу x, то значения элементов values[i] и values[less] меняются местами,
# и значение less увеличивается на 1.После завершения цикла значения элементов values[less] и values[r] также
# меняются местами.Возвращается индекс less.
# Третья функция "QuickSortImpl" используется для выполнения рекурсивной
# быстрой сортировки. Она работает следующим образом:Если l < r, вызывается функция "Partition", чтобы разделить
# массив на подмассивы.Рекурсивно вызывается "QuickSortImpl" для левого подмассива (от l до pivot - 1) и правого
# подмассива (от pivot + 1 до r).
# Четвертая функция "QuickSort" представляет обертку для вызова "QuickSortImpl" и
# передает ей исходный массив values и граничные индексы 0 и len(values) - 1.В итоге, представленные функции выполняют
# сортировку массива методом быстрой сортировки (quicksort), где каждая функция имеет свою роль в реализации алгоритма.
def Partition(values, l, r):  # разделение массива на подмассивы с элементами, меньшими и большими опорного элемента
    x = values[r]
    less = l

    for i in range(l, r):
        if values[i] <= x:
            values[i], values[less] = values[less], values[i]
            less += 1

    values[less], values[r] = values[r], values[less]
    return less


def QuickSortImpl(values, l, r):
    if l < r:
        pivot = Partition(values, l, r)
        QuickSortImpl(values, l, pivot - 1)
        QuickSortImpl(values, pivot + 1, r)


def QuickSort(values):
    QuickSortImpl(values, 0, len(values) - 1)


arr = [9, 5, 2, 7, 1, 8]
QuickSort(arr)
print(arr)  # Output: [1, 2, 5, 7, 8, 9]


########################################################################
# 3
def quick_sort(unsorted, start, end):
    """ быстрая сортировка """

    # останавливаемся, когда индекс слева достиг или превысил индек справа
    if start >= end:
        return

    # определяем позицию следующего пивота
    i_pivot = partition(unsorted, start, end - 1)

    # рекурсивный вызов левой части
    quick_sort(unsorted, start, i_pivot)

    # рекурсивный вызов правой части
    quick_sort(unsorted, i_pivot + 1, end)


def partition(unsorted, start, end):
    """ arrange(упорядочить) (left array < pivot) and (right array > pivot) """

    # выбираем значение pivot как последний элемент неотсортированного сегмента
    pivot = unsorted[end]

    # назначаем на pivot значение левого индекса
    i_pivot = start

    # проходим от начала до конца текущего сегмента
    for i in range(start, end):

        # сравниваем текущее значение со значением pivot
        if unsorted[i].value <= pivot.value:
            # меняем местами текущее значение и значенрие pivot
            swap(unsorted, i, i_pivot)

            # увеличиваем значение пивота
            i_pivot += 1

    # ставим пивот в правильную позицию, заменив со значением слева
    swap(unsorted, i_pivot, end)

    # возвращаем следующее значение pivot/разделитель
    return i_pivot


################################
# 4
def partition(nums, low, high):
    # Выбираем средний элемент в качестве опорного
    # Также возможен выбор первого, последнего
    # или произвольного элементов в качестве опорного
    pivot = nums[(low + high) // 2]
    i = low - 1
    j = high + 1
    while True:
        i += 1
        while nums[i] < pivot:
            i += 1

        j -= 1
        while nums[j] > pivot:
            j -= 1

        if i >= j:
            return j

        # Если элемент с индексом i (слева от опорного) больше, чем
        # элемент с индексом j (справа от опорного), меняем их местами
        nums[i], nums[j] = nums[j], nums[i]


def quick_sort(nums):
    # Создадим вспомогательную функцию, которая вызывается рекурсивно
    def _quick_sort(items, low, high):
        if low < high:
            # This is the index after the pivot, where our lists are split
            split_index = partition(items, low, high)
            _quick_sort(items, low, split_index)
            _quick_sort(items, split_index + 1, high)

    _quick_sort(nums, 0, len(nums) - 1)


################################
# функция слияния двух отсортированных списков
def merge_list(a, b):
    c = []
    N = len(a)
    M = len(b)

    i = 0
    j = 0
    while i < N and j < M:
        if a[i] <= b[j]:
            c.append(a[i])
            i += 1
        else:
            c.append(b[j])
            j += 1

    c += a[i:] + b[j:]  # если в одном списке кончились элементы-то добавить оставшиеся из другого списка
    return c


################################################################
# Разбиение ___Ломуто  Постройте разбиение Ломуто относительно первого числа.
def lomuto_partition(arr, low, high):
    pivot = arr[low]  # Выбираем первый элемент в качестве опорного (pivot)
    i = low  # Инициализируем индекс i равным левой границе массива

    # Проходим по массиву начиная со второго элемента
    for j in range(low + 1, high + 1):
        # Если текущий элемент меньше или равен опорному элементу,
        # то увеличиваем значение i и меняем местами текущий элемент и элемент с индексом i
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    # Меняем местами опорный элемент и элемент с индексом i
    arr[low], arr[i] = arr[i], arr[low]

    # Возвращаем индекс, по которому происходит разбиение массива
    return i


# Главная функция, вызывающая разбиение Ломуто
def lomuto_partition_main(arr):
    n = len(arr)

    # Вызываем вспомогательную функцию для разбиения массива
    # относительно первого элемента (low = 0, high = n - 1)
    pivot_index = lomuto_partition(arr, 0, n - 1)

    # Выводим разбиение массива
    for i in range(n):
        print(arr[i], end=' ')
    # print()  # Печатаем пустую строку для перехода на новую строку


# Считываем количество элементов в массиве
n = int(input())

# Считываем элементы массива
arr = list(map(int, input().split()))

# Вызываем главную функцию для разбиения массива Ломуто
lomuto_partition_main(arr)
# 5/
# В данном коде осуществляется сортировка массива arr по возрастанию с использованием алгоритма "QuickSort".
n = int(input())  # - вводится количество элементов в массиве.
arr = list(map(int, input().split()))  # - вводится сам массив.
pivot = arr[0]  # - выбирается первый элемент массива в качестве опорного элемента.
i = 0  # - переменная i используется для отслеживания индекса элементов, которые меньше опорного элемента.
# Затем происходит цикл, в котором перебираются остальные элементы массива (начиная с индекса 1).
# Если элемент меньше опорного, то инкрементируется значение i, меняется местами элементы arr[i] и arr[j],
# где j - текущий индекс элемента.
# После завершения цикла, опорный элемент меняется местами с arr[i], чтобы он стал на своём месте в отсортированном
# массиве. Наконец, с использованием *arr происходит распаковка массива и его вывод на экран.
for j in range(1, n):
    if arr[j] < pivot:
        i += 1
        arr[i], arr[j] = arr[j], arr[i]
arr[0], arr[i] = arr[i], arr[0]
print(*arr)


#############№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№
# Быстрая сортировка слиянием (merge sort) — это алгоритм, который разделяет исходный список на две части, рекурсивно
# сортирует каждую часть,
# а затем объединяет их в отсортированный список.Давайте рассмотрим основной алгоритм сортировки слиянием:
# Разделение: Разделите исходный список на две равные (или почти равные) части до тех пор, пока не останется список
# из одного элемента.Рекурсивная сортировка: Рекурсивно вызовите сортировку слиянием для каждого из двух полученных
# списков.Слияние: Объедините результаты двух сортировок в один отсортированный список.
# сортировка слиянием (merge sort)
def merge_list(a, b):
    c = []
    N = len(a)
    M = len(b)

    i = 0
    j = 0
    while i < N and j < M:
        if a[i] <= b[j]:
            c.append(a[i])
            i += 1
        else:
            c.append(b[j])
            j += 1

    c += a[i:] + b[j:]  # если в одном списке кончились элементы-то добавить оставшиеся из другого списка
    return c


# функция деления списка и слияния списков в общий отсортированный список
def split_and_merge_list(a):
    N1 = len(a) // 2
    a1 = a[:N1]  # деление массива на два примерно равной длины
    a2 = a[N1:]

    if len(a1) > 1:  # если длина 1-го списка больше 1, то делим дальше
        a1 = split_and_merge_list(a1)
    if len(a2) > 1:  # если длина 2-го списка больше 1, то делим дальше
        a2 = split_and_merge_list(a2)

    return merge_list(a1, a2)  # слияние двух отсортированных списков в один


a = [9, 5, -3, 4, 7, 8, -8]
a = split_and_merge_list(a)

print(a)


################################
# 2.
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]

    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)

    return merge(left_half, right_half)


def merge(left, right):
    result = []
    left_index = 0
    right_index = 0

    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            result.append(left[left_index])
            left_index += 1
        else:
            result.append(right[right_index])
            right_index += 1

    result.extend(left[left_index:])
    result.extend(right[right_index:])

    return result


arr = [5, 3, 8, 4, 2, 1]
sorted_arr = merge_sort(arr)
print(sorted_arr)


########################################
# 3. Сортировка слиянием
def divide(unsorted, lower, upper):
    """ рекурсивная функция для разделения массива на два подмассива для сортировки """
    if upper <= lower:  # с помощью рекурсии достигнут базовый случай
        return
    mid = (lower + upper) // 2  # получаем среднее значение для разделения
    divide(unsorted, lower, mid)  # делим массив посередине
    divide(unsorted, mid + 1, upper)
    merge(unsorted, lower, mid, mid + 1, upper)  # склеиваем отсортированные массивы


def merge(unsorted, l_lower, l_upper, r_lower, r_upper):
    """ merging two sorted arrays to one sorted array """
    i, j = l_lower, r_lower  # извлекаем левый и правый индексы
    temp = []  # инициализируем временный массив
    while i <= l_upper and j <= r_upper:  # проходим по индексам
        if unsorted[i].value <= unsorted[j].value:  # определяем, какое значение следующим вставить во временный массив
            temp.append(unsorted[i])
            i += 1
        else:
            temp.append(unsorted[j])
            j += 1
    while i <= l_upper:  # одно из условий выше заканчивается первым # поэтому обрабатываем незаконченный случай
        temp.append(unsorted[i])
        i += 1
    while j <= r_upper:
        temp.append(unsorted[j])
        j += 1
    for y, k in enumerate(range(l_lower, r_upper + 1)):  # присваиваем значения из временного массива
        unsorted[k] = temp[y]


################################################################
# Пирамидальная сортировка (Heap Sort) является усовершенствованной сортировкой выбором. Основная идея алгоритма
# заключается в построении двоичной кучи, в которой каждый родительский элемент больше или равен своим дочерним
# элементам. Затем на каждой итерации алгоритм обменивает корень кучи с последним элементом и уменьшает размер кучи
# таким образом, чтобы последний элемент оказался в правильном положении.Основный алгоритм:
# Создаем max-кучу из заданного массива.Поменять местами первый элемент (корень) кучи с последним элементом.
# Уменьшить размер кучи на 1 (исключить последний элемент из участия в дальнейшей сортировке).
# Восстановить свойство max-кучи, вызвав процедуру Heapify на уменьшенной куче.
# Повторять шаги 2-4, пока размер кучи больше 1.

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)


def heapSort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)


################################
def heap_sort(values):
    import heapq
    heapq.heapify(values)
    for i in range(len(values) - 1, -1, -1):
        heapq.heappop(values)
    return values


########################################################################
# Сортировка деревом / Tree sort
def treesort(l, r):
    m = set()
    for i in range(l, r):
        m.add(i)
    sorted_list = []
    for q in sorted(m):
        sorted_list.append(q)
    return sorted_list


########################################################################
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

    def insert(self, node):
        if node.data < self.data:
            if self.left is None:
                self.left = node
            else:
                self.left.insert(node)
        else:
            if self.right is None:
                self.right = node
            else:
                self.right.insert(node)

    def transform(self, elements=None):
        if elements is None:
            elements = []
        if self.left is not None:
            self.left.transform(elements)
        elements.append(self.data)
        if self.right is not None:
            self.right.transform(elements)
        return elements


def tree_sort(array):
    tree = TreeNode(array[0])
    for i in range(1, len(array)):
        tree.insert(TreeNode(array[i]))
    return tree.transform()


arr = [3, 5, 1, 6, 9, 8, 2]
result = tree_sort(arr)
print(result)


###########################################
# Гномья сортировка / Gnome sort

def mySort(A):
    i = 1
    while i < len(A):
        if A[i] < A[i - 1]:
            A[i], A[i - 1] = A[i - 1], A[i]
            i = i - 1 if i > 1 else i + 1
        else:
            i += 1
    return A


a = [7, 5, 3, 1, 4, 9, 3, 2]
print(mySort(a))
################################
# Метод сортировки «Bogosort»
from random import shuffle


def mySort(array):
    while True:
        for i in range(0, len(array) - 1):
            if (array[i] > array[i + 1]):
                shuffle(array)
                break
            if i == len(array) - 2: return


a = [7, 5, 3, 1, 4, 9, 3, 2]
mySort(a)
print(a)


################################
#  реализации сортировки k-статистики (selection sort):O(n^2)

def selection_sort(arr):  # сортировки выбором
    n = len(arr)
    for i in range(n):
        # Находим индекс минимального элемента в оставшейся части списка
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        # Меняем местами текущий элемент со следующим минимальным элементом
        arr[i], arr[min_index] = arr[min_index], arr[i]


def k_stat(arr, k):
    selection_sort(arr)
    return arr[k - 1]


array = [4, 2, 9, 1, 7, 5]
k = 3
result = k_stat(array, k)
print(f"{k}-ая статистика в списке {array} равна {result}")
# В этом примере мы реализуем сортировку выбором (selection sort) для сортировки массива arr. Затем мы определяем
# функцию k_stat, которая принимает массив arr и число k, и возвращает k-ую статистику — элемент массива, который
# стоит на k-ом месте после сортировки.#
################################
# Для того чтобы найти k-ю статистику в массиве с помощью алгоритма со временем выполнения линейным по отношению к
# числу элементов в массиве (то есть O(N)), мы можем использовать алгоритм QuickSelect, который является вариантом
# алгоритма быстрой сортировки QuickSort. Однако, в среднем случае его сложность равна O(N), в худшем же O(N^2).
from random import randint


def quickselect(arr, k):
    if len(arr) == 1:
        return arr[0]
    pivot = arr[randint(0, len(arr) - 1)]  # pivot точка опоры-произвольный опорный элемент в массиве
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    # Если k находится в левой части, то рекурсивно вызываем метод для левой части
    if k <= len(left):
        return quickselect(left, k)
    # Если k больше чем длина левой части плюс длина середины, то рекурсивно вызываем метод для правой части
    elif k > len(left) + len(middle):
        return quickselect(right, k - len(left) - len(middle))
    else:  # В остальных случаях k находится в середине (элементы равны pivot), поэтому возвращаем pivot
        return pivot


array = [4, 2, 9, 1, 7, 5]
k = 3
result = quickselect(array, k)
print(f"{k}-ая статистика в списке {array} равна {result}")


################################################################
# left = list(filter(lambda x: x < elem, arr))
# center = [i for i in arr if i == elem]
# right = list(filter(lambda x: x > elem, arr))
# Однозначно сказать, какой из этих вариантов будет работать быстрее, довольно сложно, поскольку это зависит от
# реализации интерпретатора Python и операционной системы. Однако, на грубом уровне, вы можете ожидать, что оба
# варианта будут работать приблизительно одинаково, потому что оба выполняют три прохода по массиву.В первом варианте
# вы используете функции filter с lambda. Во втором варианте вы используете списковые включения (list comprehensions).
# Во многих случаях списковые включения могут быть чуть быстрее, потому что они оптимизированы для выполнения операций
# над списками.
################################################################
# !!!Если вы хотите оптимизировать этот кусок кода и провести только один проход по массиву, вы можете использовать
# следующий подход, который делит массив на три части за один проход:
# O(n2),  худшем случае временную сложность O(n^2), когда выбранный опорный элемент является наименьшим или наибольшим
# элементом в списке на каждом этапе рекурсии, что приводит к самому наименее эффективному разделению списка

def quickselect(arr, k):
    if len(arr) == 1:
        assert k == 0
        return arr[0]

    pivot = arr[len(arr) // 2]
    less, equal, greater = segregate(arr, pivot)

    if k < len(less):
        return quickselect(less, k)
    elif k > len(less) + len(equal):
        return quickselect(greater, k - len(less) - len(equal))
    else:
        return pivot
        # return equal[0]


def segregate(arr, pivot):
    less, equal, greater = [], [], []
    for x in arr:
        if x < pivot:
            less.append(x)
        elif x == pivot:
            equal.append(x)
        else:
            greater.append(x)
    return less, equal, greater


array = [4, 2, 9, 1, 7, 5]
k = 2
result = quickselect(array, k)
print(f"{k + 1}-я статистика в списке {array} равна {result}")
# Обратите внимание, что индексы в Python начинаются с 0, поэтому 3-й элемент будет иметь индекс 2. Если вы хотите
# получить 3-й наименьший элемент, вам нужно задать k=2. При выводе результатов k увеличивается на 1.
# Этот код использует пользовательский выбор опорного элемента pivot и простой метод разбиения на три части
# less, equal, greater, но имеет в среднем время выполнения O(n), что делает его очень эффективным
# для выбора k-й наименьшей статистики.

# assert k == 0 это инструкция, которая используется для отлова ошибок в программе. Утверждение assert проверяет,
# является ли условие истинным. Если условие истинное, программа продолжает работать, как обычно. Если условие ложное,
# программа поднимает исключение AssertionError и выполнение программы прерывается.
# В данной программе assert k == 0 проверяет, равно ли значение k нулю. Если значение k не равно нулю, это будет
# считаться ошибкой, и программа выдаст исключение

# Выбор pivot в алгоритме Quickselect влияет на производительность алгоритма. Подходы "pivot = arr[len(arr) // 2]" и
# "pivot = arr[randint(0, len(arr) - 1)]" работают по-разному и имеют свои преимущества и моменты для упреждения.
# pivot = arr[len(arr) // 2]: Этот метод выбирает pivot как средний элемент массива. Это простой и прямой подход, но
# его эффективность имеет тенденцию варьироваться. Если ваши данные случайны и неотсортированы, это может быть
# достаточно эффективно. Однако в худшем случае, например, когда данные предварительно отсортированы, этот подход
# может привести к крайне неэффективным результатам, поскольку partition будет происходить неравномерно.
# pivot = arr[randint(0, len(arr) - 1)]: Этот метод случайно выбирает pivot. Это помогает уменьшить вероятность
# несбалансированного разделения, даже если данные уже сортированы или частично сортированы. Поэтому, на практике,
# это часто предпочтительнее, особенно для больших наборов данных или наборов данных с известной структурой.
# Этот подход известен как "Randomized Quickselect".
################################################################
# Более того, можно использовать встроенный в Python метод heapq.nsmallest, который имеет временную сложность O(N log k)
# и может быть более эффективным при большом N и небольшом k.

import heapq


# The nsmallest function will select k smallest elements, sort them, and return them as a list.
# We get the last element since we need the k-th smallest.
def k_stat(arr, k):
    return heapq.nsmallest(k, arr)[-1]


array = [4, 2, 9, 1, 7, 5]
k = 3
result = k_stat(array, k)
print(f"{k}-ая статистика в списке {array} равна {result}")


# Обратите внимание, что оба этих метода могут быть менее эффективными для очень больших данных или в определенных
# сценариях, связанных со спецификой ваших данных.
# import heapq
# heapq.nsmallest(n, iterable, key=None)Функция nsmallest() модуля heapq возвращает список с n наименьшими элементами
# из набора данных, определенного с помощью итерируемой последовательности iterable. Функция nsmallest() эквивалентна
# вызову sorted(iterable, key=key)[:n].

################################################################
# __сортировка подсчётом / counting sort__________

def countsort(seq):
    min_val = min(seq)  # определяем диапазон для списка
    max_val = max(seq)
    k = (max_val - min_val + 1)  # кол-во значений в диапазоне индексы начиная с 0 поэтому +1
    res = [0] * k  # создадим список для заполнения и заполним 0
    for now in seq:
        res[now - min_val] += 1  #

    pos = 0
    for val in range(k):
        for i in range(res[val]):  # выдаёт сколько раз число встречается
            seq[pos] = val + min_val  # запись в seq новых отсортированных значений начиная с инд=0, тк pos = 0 числа
            # отсортированные со смещением + min_val
            pos += 1  # перевод на следующий индекс
    return seq


seq = [3, 2, 5, 7, 3, 4, 3, 2]
print(countsort(seq))  # [2, 2, 3, 3, 3, 4, 5, 7]


################################################################
# 2/
def countsort(seq):
    min_val = min(seq)  # определяем диапазон для списка
    max_val = max(seq)
    k = (max_val - min_val + 1)  # кол-во значений в диапазоне индексы начиная с 0 поэтому +1
    res = [0] * k  # создадим список для заполнения и заполним 0
    for now in seq:
        res[now - min_val] += 1  # записываем счётчик для каждого числа которое равно соответсвующему равному индексу
        # число 5 в индекс=5 ..- min_val смещение влево относительно 0

    for i in range(len(res)):
        for j in range(res[i]):
            print(f'{i + min_val}', end=' ')  # 2 2 3 3 3 4 5 7

    print()
    for i in range(len(res)):
        if res[i]:  # только те которые есть
            print(f'{i + min_val}-кол-во:{res[i]}', end='; ')
            # 2-кол-во:2; 3-кол-во:3; 4-кол-во:1; 5-кол-во:1; 7-кол-во:1;


seq = [3, 2, 5, 7, 3, 4, 3, 2]
countsort(seq)


####################################
# 3!!
def counting_sort(arr):
    # Задаем диапазон значений
    min_val = 0
    max_val = 5
    # Создаем массив для подсчета количества элементов
    count = [0] * (max_val - min_val + 1)

    # Подсчитываем количество каждого элемента во входном массиве
    for num in arr:
        count[num - min_val] += 1

    # Восстанавливаем отсортированный массив из подсчитанных значений
    result = []
    for i in range(len(count)):
        result.extend([i + min_val] * count[i])
    # Метод extend используется в данном коде для объединения отсортированных подмассивов в итоговый отсортированный
    # массив.Когда мы добавляем элементы из подмассивов left и right в итоговый массив result, мы используем
    # метод extend,чтобы добавить все элементы подмассива сразу.
    return result


arr = [0, 3, 5, 2, 4, 5, 2, 3]
sorted_arr = counting_sort(arr)
print(sorted_arr)  #####


###########################
# поразрядная сортировка / Radix Sort  ___
def radix_sort(arr):
    # находим размер самого длинного числа
    max_digits = max([len(str(x)) for x in arr])
    base = 10  # основание системы счисления

    # создаём промежуточный пустой массив из 10 элементов
    bins = [[] for _ in range(base)]

    # перебираем все разряды, начиная с нулевого
    for i in range(0, max_digits):
        # для удобства выводим текущий номер разряда, с которым будем работать
        print('✅ Номер разряда → ' + str(i))

        # перебираем все элементы в массиве
        for x in arr:
            # получаем цифру, стоящую на текущем разряде в каждом числе массива
            digit = (x // base ** i) % base
            # отправляем число в промежуточный массив в ячейку, которая совпадает со значением этой цифры
            bins[digit].append(x)
        # собираем в исходный массив все ненулевые значения из промежуточного массива
        arr = [x for queue in bins for x in queue]

        print(arr)  # текущее состояние массива
        print(bins)  # текущее состояние промежуточного массива

        bins = [[] for _ in range(base)]  # очищаем промежуточный массив

    return arr


print(radix_sort([137137105157, 24395739293, 474290561035, 5, 276, 42]))
################################################################
