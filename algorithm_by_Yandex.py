# #https://education.yandex.ru/handbook/algorithms/article/polnyj-perebor-i-optimizaciya-perebora

# Выведите число перестановок P(n). В первой строке находится одно число n (1≤ n ≤7)

import math

n = int(input("Введите число n: "))

# Проверка условия 1 ≤ n ≤ 7
if n < 1 or n > 7:
    print("Число n должно быть от 1 до 7.")
else:
    # Вычисление факториала числа n
    permutations = math.factorial(n)
    print("Число перестановок P(n) =", permutations)
########################################################################
# # Выведите число сочетаний C(n,k). Формат ввода В первой строке находится два числа n (1≤n≤7), k (1≤k≤7).
# Для вычисления числа сочетаний C(n, k) можно использовать формулу:
# C(n, k) = n! / (k! * (n-k)!)# Где "!" обозначает факториал числа.# Например, если n=5 и k=3:#
# C(5, 3) = 5! / (3! * (5-3)!) = 5! / (3! * 2!) = (5 * 4 * 3 * 2 * 1) / ((3 * 2 * 1) * (2 * 1)) = 10.
# Для реализации этого решения в программе на языке Python, можно использовать функцию math.factorial()
# для вычисления факториалов чисел:

import math

n, k = map(int, input().split())

result = math.factorial(n) / (math.factorial(k) * math.factorial(n - k))

print(int(result))
# 2/
import math

n, k = map(int, input().split())
combination = math.comb(n, k)
print(combination)
# math.comb(n, k) используется для вычисления количества комбинаций из n элементов, выбранных k элементов одновременно.
# Это вычисляется с использованием формулы биномиальных коэффициентов, равной n! / (k! * (n-k)!), где n! обозначает
# факториал числа n.
################################################################
# Выведите число сочетаний с повторением С (n,k).).
# Формат ввода В первой строке находится два числа n (1≤n≤4), k (1≤k≤4).
# Для вычисления числа сочетаний с повторением С(n,k) можно воспользоваться формулой С (n + k - 1, k).

n, k = map(int, input().split())
result = 1
for i in range(k + n - 1, k, -1):
    result *= i
for i in range(n, 1, -1):
    result //= i
print(result)

################################################################
# вычисления числа сочетаний с повторениями из n объектов по k, вы можете использовать формулу:
# C(n,k)=n!/( (n−k)!⋅k!)
# Выведите число сочетаний с повторением С (n,k).
# В первой строке находятся два числа n(1≤n≤4), k(1≤k≤4).
# Выведите ответ на задачу.
import math

n, k = map(int, input().split())
comb = math.factorial(n + k - 1) // (math.factorial(k) * math.factorial(n - 1))
print(comb)


################################
def combination_with_repeats(n, k):
    numerator = factorial(n)
    denominator = factorial(n - k) * factorial(k)
    return numerator / denominator


def factorial(num):
    if num == 0 or num == 1:
        return 1
    else:
        return num * factorial(num - 1)


result = combination_with_repeats(n, k)
print(result)
################################################################
## Жадные алгоритмы
# #Бронирование переговорки
# Задано n интервалов. Требуется найти максимальное количество взаимно непересекающихся интервалов.
# Два интервала пересекаются, если они имеют хотя бы одну общую точку.
# Формат ввода
# В первой строке задано одно число n (1≤n≤100) — количество интервалов.
# В следующих n строках заданы интервалы li,ri (1 ≤ li ≤ ri ≤ 50). li и ri - начало и конец i-го интервала.
# Ввод 3 (n - intervals)
# 1 3
# 2 3
# 4 5
n = int(input())  # Ввод количества интервалов
intervals = []  # Создание списка для интервалов
for _ in range(n):
    l, r = map(int, input().split())  # Ввод левой и правой границы интервала
    intervals.append((l, r))  # Добавление интервала в список

intervals = [(1, 3), (2, 3), (4, 5)]
intervals.sort(key=lambda x: x[1])  # Сортировка интервалов по правой границе [(1, 3), (2, 3), (4, 5)]

count = 0  # Счетчик непересекающихся интервалов
last_end = -1  # Правая граница последнего выбранного интервала

for interval in intervals:
    if interval[0] > last_end:  # Если левая граница текущего интервала больше правой границы последнего выбранного инт.
        count += 1  # Увеличиваем счетчик
        last_end = interval[1]  # Обновляем правую границу последнего выбранного интервала

print(count)  # Вывод ответа на задачу 2


# 2.
def find_max_non_overlapping_intervals(intervals):
    intervals.sort(key=lambda x: x[1])  # Сортируем список intervals по правому концу интервала.

    count = 0  # Счетчик взаимно непересекающихся интервалов
    end_time = -1  # Переменная для хранения времени окончания предыдущего интервала

    for interval in intervals:
        start_time, finish_time = interval
        if start_time > end_time:  # Если начало интервала больше времени окончания предыдущего интервала
            count += 1
            end_time = finish_time  # Обновляем время окончания

    return count


n = int(input())  # Считываем количество интервалов n.
intervals = [list(map(int, input().split())) for _ in range(n)]  # Создаем список интервалов intervals.

result = find_max_non_overlapping_intervals(n, intervals)
print(result)

# 3.
# сортирует интервалы по убыванию длины (т.е. добавляем самые максимальные интервалы), которые не пересекаются
# с уже выбранными интервалами.
intervals = [(1, 2), (1, 3), (4, 10)]
intervals.sort(key=lambda x: x[1] - x[0], reverse=True)  # [(4, 10), (1, 3), (1, 2)]
count = 0  # Счетчик непересекающихся интервалов
set_interval = set()
max_intervals = []  # max intervals to add
for interval in intervals:
    set_now = set(range(interval[0], interval[-1] + 1))
    if not set_now & set_interval:  # set(set_now).intersection( set_interval)
        set_interval = set_interval.union(set_now)  # set_interval | set_now
        max_intervals.append(interval)
        count += 1
print(count, set_interval, max_intervals, sep='\n')


# 2
# {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
# [(4, 10), (1, 3)]
######################################################################
# Камни
# Вы играете в игру >: игру для двух игроков с двумя наборами камней по
# n и m штук. С каждым ходом один игрок может взять один камень (из любого набора) или два камня (по одному из обоих). Когда камень забрали, он выходит из игры. Побеждает игрок, который заберет последний камень. Первый ход за вами.
# Вы и ваш оппонент играете оптимально.# Формат ввода
# В первой строке содержится два числа # (1≤n≤10),
# (1≤m≤10) — количество ваших камней и количество камней у вашего оппонента.
# Формат вывода# В единственной строке выведите
# Loose, если вы заведомо проиграете, и # Win,
def game_result(n, m):
    if n % 2 == 0 and m % 2 == 0:
        print('Loose')
    else:
        print('Win')


n, m = map(int, input().split())
print(game_result(n, m))


###################################################################
# Ханойские башни
# Головоломка <<Ханойские башни>> состоит из трёх стержней, пронумеруем их слева направо: 1, 2 и 3.
# Также в головоломке используется стопка дисков с отверстием посередине. Радиус дисков уменьшается снизу вверх.
# Изначально диски расположены на левом стержне (стержень 1), самый большой диск находится внизу.
# Диски в игре перемещаются по одному со стержня на стержень. Диск можно надеть на стержень, только если он пустой
# или верхний диск на нём большего размера, чем перемещаемый.
# Цель головоломки — перенести все диски со стержня 1 на стержень 3.
# Требуется найти последовательность ходов, которая решает головоломку <<Ханойские башни>>.
# Формат ввода В первой строке задано одно число �n (3≤�≤10)(3≤n≤10) — количество дисков на первой башне.
# Формат вывода# В первой строке выведите количество операций k.
# В следующих k строках выведите по два числа в каждой xi,yi (1≤xi,yi≤3) —
# переместить верхний диск со стержня xi на стержень yi.

def HanoiTowers(n, from_Peg, to_Peg, temp_Peg, lst):
    global move
    if n > 0:
        HanoiTowers(n - 1, from_Peg, temp_Peg, to_Peg, lst)
        # print(f'переложить с {from_Peg} на {to_Peg}')
        lst.append([from_Peg, to_Peg])
        move += 1
        HanoiTowers(n - 1, temp_Peg, to_Peg, from_Peg, lst)


if __name__ == '__main__':
    n = int(input())
    move = 0
    lst = []
    HanoiTowers(n, 1, 3, 2, lst)
    print(move)
    # [print(*i) for i in lst]
    [print(f'переложить с {i[0]} на {i[1]}') for i in lst]


################################################################################
# Ханойские башни
# Головоломка <<Ханойские башни>> состоит из трёх стержней, пронумеруем их слева направо: 1, 2 и 3.
# Также в головоломке используется стопка дисков с отверстием посередине. Радиус дисков уменьшается снизу вверх.
# Изначально диски расположены на левом стержне (стержень 1), самый большой диск находится внизу.
# Диски в игре перемещаются по одному со стержня на стержень. Диск можно надеть на стержень, только если он пустой
# или верхний диск на нём большего размера, чем перемещаемый.
# Цель головоломки — перенести все диски со стержня 1 на стержень 3.
# Немного изменим правила. Теперь головоломка состоит из четырех стержней, а цель головоломки —
# перенести все диски со стержня 1 на стержень 4. Найдите минимальное количество ходов, за которое можно решить головол
# В единственной строке выведите ответ на задачу.
# решение не верно!!
def hanoi(n, source, target, auxiliary, extra):
    global move
    if n > 0:
        hanoi(n - 2, source, extra, target, auxiliary)
        print(f"Переместить диск {n} со стержня {source} на стержень {extra}")
        print(f"Переместить диск {n - 1} со стержня {source} на стержень {target}")
        print(f"Переместить диск {n} со стержня {extra} на стержень {target}")
        move += 1
        hanoi(n - 2, auxiliary, target, source, extra)


move = 0
n = 4  # Количество дисков
source = 1  # Начальный стержень
target = 3  # Целевой стержень
auxiliary = 4  # Вспомогательный стержень
extra = 2  # Дополнительный стержень

hanoi(n, source, target, auxiliary, extra)
print(move)

################################################################
# Сортировка выбором. Реализуйте сортировку выбором.
n = int(input())
arr = list(map(int, input().split()))
for i in range(len(arr)):
    min_indx = i
    for j in range(i + 1, len(arr)):
        if arr[j] < arr[min_indx]:
            min_indx = j
    arr[i], arr[min_indx] = arr[min_indx], arr[i]

print(*arr)
########################################################
# Слияние сортированных последовательностей
# Задано # n отсортированных по неубыванию последовательностей.
# Требуется найти отсортированную по неубыванию конкатенацию этих последовательностей.
# Запрашиваем у пользователя количество последовательностей
n = int(input())

# Создаем пустой список, в который будем добавлять последовательности
sequences = []

# Цикл для получения последовательностей от пользователя
for i in range(n):
    # Запрашиваем у пользователя саму последовательность и преобразуем её в список чисел
    sequence = list(map(int, input().split()))
    # Добавляем последовательность в список sequences
    sequences.append(sequence)

# Создаем пустой список, в который будем добавлять все числа из всех последовательностей
result = []

# Цикл для добавления чисел из всех последовательностей в список result
for sequence in sequences:
    # Расширяем список result, добавляя все числа из текущей последовательности
    result.extend(sequence)

# Сортируем список result в возрастающем порядке
result.sort()

# Выводим все числа из списка result, через пробел
for num in result:
    print(num, end=' ')


################################################################
# Сортировка слиянием  Реализуйте сортировку слиянием.
# Для реализации сортировки слиянием, нам понадобится две функции: функция merge_sort, которая разделяет массив на две
# половины и рекурсивно сортирует их, и функция merge, которая объединяет отсортированные половины обратно в один массив
# Сначала реализуем функцию merge, которая будет принимать на вход два отсортированных массива и возвращать
# объединенный отсортированный массив:
def merge(left, right):
    merged = []
    l = r = 0
    while l < len(left) and r < len(right):
        if left[l] <= right[r]:
            merged.append(left[l])
            l += 1
        else:
            merged.append(right[r])
            r += 1
    merged += left[l:]
    # merged.extend(left[l:])
    merged += right[r:]
    # merged.extend(right[:r])
    return merged


# Затем реализуем функцию merge_sort, которая будет разделять массив на две половины и рекурсивно сортировать их:
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)


# Теперь можем считать числа из ввода, вызвать функцию merge_sort и вывести отсортированный массив:
n = int(input())
arr = list(map(int, input().split()))
sorted_arr = merge_sort(arr)
print(*sorted_arr)

##############################
# fibonacci
# recursion ( more memory) Рекурсивный алгоритм требует так много времени, потому что он повторяет множество одинаковых вычислений
n = int(input(''))


def fib(n):
    if n < 2:
        return n
    return fib(n - 1) + fib(n - 2)


if __name__ == "__main__":
    print(fib(n))


# 2/ iteration method
def fib(n):
    if n <= 1:
        return n
    num_1, num_2 = 0, 1
    for _ in range(2, n + 1):
        res_now = num_1 + num_2  # без хранения всего массива
        num_1 = num_2
        num_2 = res_now
    return num_2


# 3/мемоизация: при вычислении чего-либо сохраните это в структуре данных, чтобы избежать повторных вычислений в будущем
def fibonacci(n, memo={}):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    elif n in memo:
        return memo[n]
    else:
        memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)
        return memo[n]


print(fibonacci(10))  # Вывод: 55


# 4/ Последняя цифра числа Фибоначчи
def fibonacci_last_digit(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1

    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, (a + b) % 10

    return b % 10


n = int(input("Введите номер числа Фибоначчи: "))
last_digit = fibonacci_last_digit(n)
print(f"Последняя цифра числа Фибоначчи под номером {n} равна {last_digit}")

################################################################
# Наибольший общий делитель GCD(a,b)  двух положительных целых чисел  и  — это самое большое целое число
# , на которое можно поделить  и   без остатка
# 1.
a, b = map(int(input()))


def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)


################################################################
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


num1 = 24
num2 = 36
result = gcd(num1, num2)
print("Наибольший общий делитель чисел", num1, "и", num2, "равен", result)
# 2.
import math


def gcd(a, b):
    return math.gcd(a, b)


# Наименьшее общее кратное LCM(a,b)  для двух положительных целых чисел a и b — это самое маленькое целое число
# m, которое можно разделить и на a, и на b.
a, b = map(int, input().split())


def gcd(a, b):
    # Алгоритм Евклида для вычисления наибольшего общего делителя (НОД)
    while b != 0:
        temp = b
        b = a % b
        a = temp
    return a


def lcm(a, b):
    # НОК = a * b / НОД
    return (a * b) // gcd(a, b)


# Пример использования функции
num1 = int(input("Введите первое число: "))
num2 = int(input("Введите второе число: "))

lcm_result = lcm(num1, num2)
print("Наименьшее общее кратное:", lcm_result)
# 2.
import math

a = int(input("Введите первое число: "))
b = int(input("Введите второе число: "))

lcm = math.lcm(a, b)

print("Наименьшее общее кратное чисел", a, "и", b, "равно", lcm)


################################
# Жадные алгоритмы
# Задача «Размен»
# Размен: 1, 5, 10, 20, 50
# Предположим, что у кассира есть бесконечное количество монет номиналами 11, 55, 1010, 2020 и 5050.
# Найдите набор монет, с суммарным номиналом  в котором наименьшее количество монет. Требуется вывести
# номиналы монет в этом наборе.
# 1.
# Алгоритм решения этого кода основан на динамическом программировании и использует метод "минимальных монет" для
# размена суммы денег.
# - В начале определяется список возможных номиналов монет и создается список num_coins длиной (money + 1),
# который будет хранить количество монет для каждой суммы от 0 до money.
# - Затем устанавливается значение num_coins[0] равным 0, так как для суммы 0 не требуются монеты.
# - Создается список used_coins, который будет хранить список использованных монет для каждой суммы от 0 до money.
# - Далее, для каждой суммы m от 1 до money проходим по каждому номиналу монет.
# - Если текущая сумма больше или равна номиналу монеты и количество монет для (текущая сумма - номинал) плюс одна
# монета меньше количества монет для текущей суммы, то обновляем количество монет и список использованных монет.
# - На каждом шаге выбирается минимальное количество монет для текущей суммы.
# - В итоге, значение num_coins[money] будет содержать минимальное количество монет для размена суммы money.
# # - Чтобы восстановить список использованных монет, используется список used_coins[money].
# В конце программа выводит количество монет и список использованных монет для размена введенной суммы.

def exchange(money):
    coins = [1, 5, 10, 20, 50]  # Возможные номиналы монет
    num_coins = [float('inf')] * (money + 1)  # Инициализация количества монет для каждой суммы
    num_coins[0] = 0  # Для суммы 0 не нужны монеты
    used_coins = [[] for _ in range(money + 1)]  # Инициализация списка использованных монет

    for m in range(1, money + 1):  # Для каждой суммы
        for coin in coins:  # Проходим по каждому номиналу монет
            if m >= coin and num_coins[m - coin] + 1 < num_coins[m]:
                # Если текущая сумма больше или равна номиналу монеты и
                # количество монет для (текущая сумма - номинал) плюс одна
                # монета меньше количества монет для текущей суммы,
                # то обновляем количество монет и список использованных монет
                num_coins[m] = num_coins[m - coin] + 1
                used_coins[m] = used_coins[m - coin] + [coin]

    return num_coins[money], *used_coins[money]


n = int(input())  # Ввод суммы
count, *coins = exchange(n)  # Подсчет количества монет и использованных монет
print(count)  # Вывод количества монет
print(*coins)  # Вывод использованных монет
################################################################
# Специи Вор пробрался в лавку специй и нашел там n видов специй. В его рюкзак можно сложить до
# W фунтов, поэтому забрать все он не сможет. Предположим, в лавке находится   фунтов специй с номером i и стоимостью
# Первая строка ввода содержит n специй и вместимость рюкзака W. Следующие n строк указывают цену и вес специй.
# i-я строка включает в себя цену
# Формат вывода Максимальное значение специй, которые вместятся в рюкзак.

# n, W = map(int, input().split())
# c = [0] * n
# w = [0] * n
# for i in range(n):
#     c[i], w[i] = map(int, input().split())

n, W = 1, 1000
c, w = [500], [30]

d = {}  # dictionary - cost:weight
for i in range(n):
    c_i, w_i = c[i], w[i]
    d[c_i] = w_i
c = sorted(d, reverse=True)

# print(d)  # {60: 20, 100: 50, 120: 30}
# print(c)  # [120, 100, 60]

weight = 0
cost = 0
count = W
for i in range(n):
    if w[i] > W:
        while weight + (w[i] / w[i]) <= W and count:
            weight += w[i] / w[i]
            cost += (c[i] / w[i])
            count -= 1
    else:
        if weight + w[i] <= W and count:
            weight += w[i]
            cost += c[i]
            count -= 1

print(f'{cost:.3f}')
########################################################################
# Сувениры Турист зашел в сувенирную лавку и нашел там много привлекательных вариантов подарков друзьям и родным.
# Всего в лавке n сувениров, стоимость i-го сувенира i​  рублей.пределите, какое наибольшее количество сувениров
# сможет купить турист, если он может потратить не более �S рублей.
n, s = map(int, input().split())
prices = []

for _ in range(n):
    price = int(input())
    prices.append(price)

prices.sort()
count = 0
for i in range(n):
    if s - prices[i] >= 0:
        s -= prices[i]
        count += 1

print(count)
################################
# Рекламная кампанияУ вас есть популярная страница в интернете, на которой есть �n рекламных мест. Вы хотите
# продать их рекламодателям. Аналитики рассчитывают на �2clicks 2​ licks n​  кликов в день, соответственно.
# С вами связались �n рекламодателей, которые готовы заплатить �price 1​Как подобрать пары рекламных мест и
# рекламодателей так, чтобы получить максимальную прибыль?


n = int(input())
prices = list(map(int, input().split()))
clicks = list(map(int, input().split()))

prices.sort()
clicks.sort()

total = []
for i in range(n):
    total.append(prices[i] * clicks[i])

print(sum(total))
################################################################
# Сбор подписей Ваша задача — собрать подписи всех жильцов в доме. Вам известно время, в которое каждый
# из жильцов находится дома. Вы хотели бы собрать все подписи, приходя в дом минимальное количество раз.
# Для простоты давайте предположим, что вы сразу же собираете подписи всех жильцов, находящихся дома, когда заходите.
# Формат ввода Количество сегментов в первой строке — � n. Каждая из следующих � n строк содержит два целых числа
# � � l i​и � � r i​(разделены пробелом), которые указывают на координаты границ � i-го сегмента.
# Ограничения: 1 ≤ � ≤ 100 1≤n≤100; 0 ≤ � � ≤ � � ≤ 1 0 9 0≤l i​≤r i​≤10 9 для всех � i.
# Формат вывода Минимальное количество � k точек на первой строке и координаты � k точек целыми числами
# (разделены пробелом) на второй строке. Выводить точки можно в любом порядке. При наличии нескольких наборов точек,
# можно вывести любой из них.
# Таким образом, мы приходим к следующему алгоритму:
# -добавить в решение минимальное значение правой границы
# - отбросить все сегменты, покрытые
# - повторить.
n = int(input())
segments = []
for i in range(n):
    l, r = map(int, input().split())
    segments.append((l, r))

segments = sorted(segments, key=lambda x: x[1])
points = [segments[0][1]]
for i in range(1, n):
    if segments[i][0] > points[-1]:
        points.append(segments[i][1])

print(len(points))
print(" ".join(map(str, points)))
# 2.
segments.sort(key=lambda x: x[1])
points = []
while segments:
    r_m = segments[0][1]
    points.append(r_m)
    segments = [seg for seg in segments if seg[0] > r_m]

print(len(points))
print(" ".join(map(str, points)))


###################################################
# Количество призов Вы занимаетесь организацией соревнований для детей, и у вас есть � n конфет, которые вы раздадите в качестве призов. Вы хотите отдать эти конфеты тем, кто займет первые � k мест в соревнованиях, и распределить конфеты так, чтобы за более высокое место всегда выходило больше конфет.
# # Чтобы порадовать как можно больше детей, вам понадобится найти самое большое значение � k, при котором это возможно.
# # Формат ввода Целое число � n.# # Ограничения: 1 ≤ � ≤ 1 0 9 1≤n≤10 9
# Формат вывода Единственная строка: максимальное число � k, при котором � n можно представить как сумму � k различных положительных целых чисел
# В данной задаче нам требуется найти максимальное значение k, при котором можно представить n как сумму
# k различных положительных целых чисел. Мы можем использовать метод перебора, начиная с k = 1 и увеличивая его до тех
# пор, пока (k * (k + 1)) / 2 не станет больше n. Как только это произойдет, мы вернем предыдущее значение k.

def find_k(n):
    k = 1
    while (k * (k + 1)) // 2 <= n:
        k += 1
    return k - 1


n = int(input())
print(find_k(n))
########################################################################
# Максимальный оклад В качестве последнего вопроса на собеседовании будущий начальник дает вам � n бумажек с одним
# числом на каждой и говорит составить из них самое большое число. Получившееся число — ваша зарплата,
# поэтому вы очень замотивированы решить эту задачу!Формат ввода Первая строка ввода содержит целое число � n.
# Вторая строка содержит целые числа � 1 , … , � � a 1​,…,a n​.
# Ограничения: 1 ≤ � ≤ 100 1≤n≤100; 1 ≤ � � ≤ 1 0 3 1≤a i​≤10 3 для всех 1 ≤ � ≤ � 1≤i≤n.
# Формат вывода Самое большое возможное число, которое состоит из � 1 , … , � � a 1​,…,a n​.код на питоне
n = int(input())
numbers = list(map(int, input().split()))


def best_num(num):
    lst = []
    for i in range(len(num)):
        s = str(num[i])
        if len(s) > 1:
            l = list(map(int, s))
            lst.extend(l)
        else:
            lst.append(num[i])
    lst = sorted(lst, reverse=True)
    n = int(''.join(map(str, lst)))
    return n


print(best_num(numbers))
########################################################################
# Теннисный турнир В теннисном турнире принимают участие � n роботов-спортсменов. Про каждого из них известно,
# насколько хорошо он играет. Умение � i-го робота описывается числом � � a i​. В игре двух роботов всегда
# побеждает тот, у кого умение играть в теннис больше. В этой задаче мы будем полагать, что все значения � � a
# i​различны.# В каждом раунде теннисного турнира роботы разбиваются на пары. Если количество продолжающих
# участие в турнире нечетное, то один из роботов без игры проходит в следующий раунд. После игры в каждой из пар,
# в следующий раунд выходит победитель, а проигравший выбывает из турнира.# Определите, какое наибольше количество
# игр в турнире может выиграть � k-й робот-спортсмен.# Формат ввода В первой строке входных данных заданы число
# роботов � n и интересующий нас номер � k. Во второй строке записаны � n чисел � � a i​.
# Ограничения: 1 ≤ � ≤ 1000 1≤n≤1000, 1 ≤ � ≤ � 1≤k≤n, 1 ≤ � � ≤ � 1≤a i​≤n. Все � � a i​различны.
# Формат вывода Выведите наибольшее количество игр в турнире, которые может выиграть робот с номером � k..
# описать общий алгоритм решения и код на питоне
# Для решения этой задачи мы можем использовать следующий алгоритм:
# 1. Прочитать числа n и k из входных данных.
# 2. Прочитать значения a_1, a_2, ..., a_n из входных данных.
# 3. Отсортировать значения a_1, a_2, ..., a_n в порядке убывания.
# 4. Найти индекс k в отсортированном списке значений. Это позволит нам найти умение k-го робота.
# 5. Вывести на экран количество чисел в списке a_1, a_2, ..., a_k-1, которые больше умения k-го робота.


n, k = map(int, input().split())
abilities = list(map(int, input().split()))

sorted_abilities = sorted(abilities, reverse=True)
k_ability = sorted_abilities[k - 1]

count = 0
for ability in sorted_abilities:
    if ability > k_ability:
        count += 1

print(count)

########################################################################
# 1. Введите число роботов (n) и интересующий нас номер робота (k).
# 2. Считайте значения умений игроков (a_i) и сохраните их в список.
# 3. Отсортируйте список умений игроков в порядке убывания.
# 4. Найдите позицию интересующего нас робота в отсортированном списке.
# 5. Подсчитайте количество игр, которые может выиграть робот с номером k следующим образом:
#    а) Если позиция робота k в отсортированном списке меньше или равна (n+1)/2, тогда он будет выигрывать
#       в каждом раунде до финала, а значит, сможет выиграть (n-1)/2 игр (т.к. в финале победитель сыграет
#       только одну игру).
#    б) Если позиция робота k в отсортированном списке больше (n+1)/2, тогда он будет выигрывать только
#       после первого раунда, а значит, сможет выиграть (n-1)/2 игр.
# Пожалуйста, обратите внимание, что в данном коде мы используем индекс k-1, так как в Python индексация начинается
# с 0. Также важно отметить, что решение предполагает, что все значения умений игроков различны и что все числа
# вводятся корректно.

n, k = map(int, input().split())
abilities = list(map(int, input().split()))

abilities.sort(reverse=True)
k_position = abilities.index(abilities[k - 1])

if k_position <= (n + 1) / 2:
    games_won = (n - 1) // 2
else:
    games_won = (n - 1) // 2 - 1

print(games_won)
#######################################################################################################
# Двоичный поиск Ваша задача --- найти индекс элемента в сортированной последовательности равного � q.
# Формат ввода Отсортированный массив � K неповторяющихся целых чисел и целое число � q. Первые две строки
# ввода содержат целое число � n и последовательность � 0 < � 1 < … < � � − 1 k 0​<k 1​<…<k n−1​из � n
# неповторяющихся положительных целых чисел в возрастающем порядке. Следующая строка содержит целое число � q.
# Ограничения: 1 ≤ � ≤ 3 ⋅ 1 0 4 1≤n≤3⋅10 4 ; 1 ≤ � � ≤ 1 0 9 1≤k i​≤10 9 для всех 0 ≤ � < � 0≤i<n;
# 1 ≤ � ≤ 1 0 9 1≤q≤10 9 .Формат вывода Позиция элемента в � K равного � q или − 1 −1 при отсутствии
# такого элемента.код на питоне

# 1/not binary search this is iterable method
n = int(input())
arr = list(map(int, input().split()))
q = int(input())


def get_q(n):
    for i in range(n):
        if arr[i] == q:
            return i
    return -1


print(get_q(n))


# 2/ binary_search
def get_q(arr, q):
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == q:
            return mid
        elif arr[mid] < q:
            left = mid + 1
        else:
            right = mid - 1
    return -1


# 3/
def binary_search(arr, low, high, q):
    if high >= low:
        mid = (low + high) // 2
        if arr[mid] == q:
            return mid
        elif arr[mid] > q:
            return binary_search(arr, low, mid - 1, q)
        else:
            return binary_search(arr, mid + 1, high, q)
    else:
        return -1


# n = int(input())
# arr = list(map(int, input().split()))
# q = int(input())
result = binary_search(arr, 0, n - 1, q)


################################
# Множественный поиск ключей в отсортированной последовательности Ваша задача --- для � m значений � � q
# i​необходимо проверить, входит ли � � q i​в � K.Формат ввода Отсортированный массив � K неповторяющихся
# целых чисел и массив целых чисел �[ � 0 , … , � � − 1 ] Q=[q 0​,…,q m−1​].Первые две строки ввода содержат
# целое число � n и последовательность � 0 < � 1 < … < � � − 1 k 0​<k 1​<…<k n−1​из � n неповторяющихся
# положительных целых чисел в возрастающем порядке.Следующие две строки содержат целое число � m и � m положительных
# целых чисел � 0 , � 1 , … , � � − 1 q 0​,q 1​,…,q m−1​.Ограничения: 1 ≤ � ≤ 3 ⋅ 1 0 4 1≤n≤3⋅10 4 ;
# 1 ≤ � ≤ 1 0 5 1≤m≤10 5 ; 1 ≤ � � ≤ 1 0 9 1≤k i​≤10 9 для всех 0 ≤ � < � 0≤i<n; 1 ≤ � � ≤ 1 0 9 1≤q j​≤10 9
# для всех 0 ≤ � < � 0≤j<m.Формат вывода Для всех � i от 0 0 до � − 1 m−1 выведите индекс 0 ≤ � ≤ � − 1 0≤j≤n−1,
# чтобы � �� � k j​=q i​или − 1 −1 при отсутствии такого индекса

# Идея решения заключается в применении бинарного поиска для каждого элемента массива Q в массиве K.
# Функция binary_search осуществляет поиск элемента target в массиве arr и возвращает его индекс, если он найден,
# и -1 в противном случае. Функция multiple_search принимает массив K и массив Q, применяет бинарный поиск для каждого
# элемента в массиве Q и возвращает массив с найденными индексами или -1, если элемент не найден.
# Затем происходит считывание вводных данных, вызов функции multiple_search и вывод результатов.
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1


def multiple_search(K, Q):
    n = len(K)
    m = len(Q)
    result = []

    for i in range(m):
        index = binary_search(K, Q[i])
        result.append(index)

    return result


n = int(input())
K = list(map(int, input().split()))
m = int(input())
Q = list(map(int, input().split()))

result = multiple_search(K, Q)

for index in result:
    print(index)

#######################################################################################################
# Подсчет количества вхождений элементов Ваша задача --- для � m значений � � q i​необходимо найти количество
# вхождений � � q i​в � K.Формат ввода Отсортированный массив � K целых чисел и массив целых чисел �
# [ � 0 , … , � � − 1 ] Q=[q 0​,…,q m−1​].Первые две строки ввода содержат целое число � n и
# последовательность � 0 ≤ � 1 ≤ … ≤ � � − 1 k 0​≤k 1​≤…≤k n−1​из � n положительных целых чисел в возрастающем
# порядке.Следующие две строки содержат целое число � m и � m положительных целых чисел � 0 , � 1 , … , � � − 1
# q 0​,q 1​,…,q m−1​.Ограничения: 1 ≤ � ≤ 1 0 5 1≤n≤10 5 ; 1 ≤ � ≤ 1 0 5 1≤m≤10 5 ;
# 1 ≤ � � ≤ 1 0 9 1≤k i​≤10 9 для всех 0 ≤ � < � 0≤i<n; 1 ≤ � � ≤ 1 0 9 1≤q j​≤10 9 для всех 0 ≤ � < � 0≤j<m.
# Формат вывода Для всех � i от 0 0 до � − 1 m−1 выведите количество индексов 0 ≤ � ≤ � − 1 0≤j≤n−1, для которых � �
# � � k j​=q i
n = int(input())
k = list(map(int, input().split()))

m = int(input())
q = list(map(int, input().split()))

count = {}

for i in range(n):
    if k[i] in count:
        count[k[i]] += 1
    else:
        count[k[i]] = 1

for i in range(m):
    if q[i] in count:
        print(count[q[i]])
    else:
        print(0)
# 2/
from collections import defaultdict


# defaultdict - это класс в модуле collections, который при создании автоматически устанавливает значения по умолчанию
# для новых ключей в словаре. В данном случае, defaultdict(int) устанавливает значения по умолчанию для ключей в
# словаре occurrences равными нулю.
# dict() - это обычный класс словаря, который не имеет значения по умолчанию. Если использовать dict() вместо
# defaultdict(int), то при обращении к несуществующему ключу в словаре, будет возбуждено исключение KeyError.
# В таком случае, вам нужно будет проверять наличие ключа в словаре перед добавлением значения.
# for num in K:
#         if num in occurrences:
#             occurrences[num] += 1
#         else:
#             occurrences[num] = 1

def count_occurrences(K, Q):
    occurrences = defaultdict(int)
    result = []

    for num in K:
        occurrences[num] += 1

    for num in Q:
        result.append(occurrences[num])

    return result


result = count_occurrences(k, q)
for i in result:
    print(i, sep='\n')
#################################################################
# Поиск доминирующего элемента Ваша задача --- проверить, содержит ли данная последовательность элемент, который
# встречается более половины раз.# Формат ввода Первая строка содержит целое число � n, следующая ---
# последовательность � n целых неотрицательных чисел � 0 , … , � � − 1 a 0​,…,a n−1​.
# Ограничения: 1 ≤ � ≤ 1 0 5 1≤n≤10 5 ; 0 ≤ � � ≤ 1 0 9 0≤a i​≤10 9 для всех 0 ≤ � < � 0≤i<n.
# Формат вывода Выведите 1 1, если в последовательности содержится элемент, который встречается больше,
# чем � / 2 n/2 раз, и 0 0 в противном случае. код на питоне
from collections import defaultdict

n = 5
lst = [2, 3, 9, 2, 2]


def max_num(lst):
    d = defaultdict(int)
    for i in lst:
        d[i] += 1

    for i in d:
        if d[i] > len(lst) / 2:
            return 1
    return 0


print(max_num(lst))
#######################################################################################################
# Поиск трех доминирующих элементов Дана последовательность � a из � n целых чисел.# Ваша задача --- проверить,
# содержит ли данная последовательность элементы, которые встречаются более � / 4 n/4 раз.# Формат ввода Первая
# строка содержит целое число � n, следующая --- последовательность � n целых неотрицательных чисел � 0 , … , � � − 1 a
# 0​,…,a n−1​.# Ограничения: 1 ≤ � ≤ 1 0 5 1≤n≤10 5 ; 0 ≤ � � ≤ 1 0 9 0≤a i​≤10 9 для всех 0 ≤ � < � 0≤i<n.
# Формат вывода Выведите 1 1, если в последовательности содержится три элемента, которые встречаются
# более � / 4 n/4 раз, и 0 0 в противном случае.

from collections import defaultdict

# n = int(input())
# lst = list(map(int, input().split()))
n = 11
lst = [0, 9, 2, 3, 9, 0, 2, 9, 2, 3, 3]


def max_num(l):
    d = defaultdict(int)
    for i in l:
        d[i] += 1

    count = 0
    for i in d:
        if d[i] > len(l) / 4:
            count += 1
    if count == 3:
        return 1
    return 0


print(max_num(lst))  # 1


###########################################################################################################
# Количество инверсий Дан массив � a из � n целых чисел.
# Необходимо вычислить количество инверсий в этом массиве.
# Инверсия -- это такая пара индексов � , � i,j, что ai>aj при  i<j и � �
def merge_sort(arr):
    if len(arr) <= 1:
        return arr, 0

    mid = len(arr) // 2
    left, inversion_left = merge_sort(arr[:mid])
    right, inversion_right = merge_sort(arr[mid:])
    merged, inversion_merge = merge(left, right)

    inversions = inversion_left + inversion_right + inversion_merge
    return merged, inversions


def merge(left, right):
    merged = []
    inversion = 0
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            inversion += len(left) - i
            j += 1

    while i < len(left):
        merged.append(left[i])
        i += 1

    while j < len(right):
        merged.append(right[j])
        j += 1

    return merged, inversion


def count_inversions(arr):
    _, inversions = merge_sort(arr)
    return inversions


n = int(input())
arr = list(map(int, input().split()))

# Вычисление количества инверсий
result = count_inversions(arr)
print(result)
# изует алгоритм сортировки слиянием и подсчитывает количество инверсий при слиянии двух отсортированных массивов.
# Общее количество инверсий получается путем сложения инверсий в левой половине, инверсий в правой половине и
# инверсий при слиянии.

# 2/ O(n2)
inversions = 0  # переменная для подсчета количества инверсий
# пробегаем по каждому элементу массива
for i in range(n):
    # сравниваем текущий элемент с каждым элементом после него
    for j in range(i + 1, n):
        # если текущий элемент больше элемента после него, это инверсия
        if arr[i] > arr[j]:
            inversions += 1


#######################################################################################################
# Программа использует динамическое программирование для решения задачи оптимального размена.
# Сначала вводим целое число money с помощью функции input().
# Затем создаем список coins, который содержит номиналы монет (1, 3, 4).
# Создаем список dp длиной (money + 1) и заполняем его значениями бесконечности. Значение dp[0] равно 0, так как
# для представления 0 монет не требуется.
# Затем используем два вложенных цикла: первый цикл перебирает значения от 1 до money, второй цикл перебирает номиналы
# монет в списке coins.
# Для каждого значения i и каждого номинала монеты coin проверяем, если i больше или равно coin, то обновляем
# значение dp[i] как минимум из текущего значения dp[i] и значения dp[i - coin] + 1.
# После выполнения циклов выводим значение dp[money], которое будет содержать минимальное количество монет,
# необходимых для представления числа money.
# Пример 1: Ввод: 18 Вывод: 5
# Это означает, что для представления числа 18 требуется минимальное количество монет, равное 5

def optimal_exchange(money):
    # Создаем массив dp размером money + 1 и заполняем его максимальными значениями
    dp = [float('inf')] * (money + 1)
    # Базовое значение - чтобы получить 0 монет, нам не нужно ни одной операции
    dp[0] = 0

    # Для каждого номинала монеты проверяем, можно ли получить меньшее число монет
    for coin in [1, 3, 4]:
        for amount in range(coin, money + 1):
            dp[amount] = min(dp[amount], 1 + dp[amount - coin])

    # Возвращаем минимальное количество монет для заданного числа
    return dp[money]


# Считываем число money
money = int(input())

print(optimal_exchange(money))


# 2\ через жадный алгоритм не верное решение
def optimal_exchange(money):
    # Счетчик количества монет
    count = 0
    # Проверяем, можно ли разменять монету достоинством 4
    while money >= 4:
        # Вычитаем 4 и увеличиваем счетчик
        money -= 4
        count += 1
    # Проверяем, можно ли разменять монету достоинством 3
    while money >= 3:
        # Вычитаем 3 и увеличиваем счетчик
        money -= 3
        count += 1
    # Оставшаяся сумма будет разменяна монетами достоинством 1
    count += money
    return count


# Считываем число money
money = 34

# Вызываем функцию и выводим результат
print(optimal_exchange(money))

###########################################################################################################
# Расстояние редактирования В вычислительной биологии есть множество применений задаче <<Редакционное расстояние>>:
# обработка текстов на естественном языке, проверка правописания и множество других сфер. Например,
# биологи зачастую вычисляют редакционное расстояние, когда ищут мутации, вызывающие болезни.
# Редакционное расстояние между двумя строками определяется как минимальное число односимвольных вставок,
# удалений и замен, необходимых для преобразования одной строки в другую. Формат ввода Две отдельных строки,
# состоящие из строчных букв латинского алфавита. Ограничения: длина обоих строк не меньше 1 1 и не больше 100 100.
# Формат вывода Найдите редакционное расстояние между ними. Пример 1 Ввод abacab bacacaba Вывод 3
# Данный код решает задачу на нахождение расстояния Левенштейна между двумя строками s1 и s2.
# Расстояние Левенштейна определяется как минимальное количество операций (вставок, удалений и замен),
# необходимых для превращения одной строки в другую.
# Алгоритм решения:
# 1. Считываем строки s1 и s2.
# 2. Создаем матрицу d размером (len(s1)+1) x (len(s2)+1) и заполняем ее нулями.
# 3. Заполняем первую строку матрицы значениями от 0 до len(s2), т.е. каждому символу строки s2 соответствует свой
# столбец в матрице.
# 4. Заполняем первый столбец матрицы значениями от 0 до len(s1), т.е. каждому символу строки s1 соответствует
# своя строка в матрице.
# 5. Заполняем матрицу d следующим образом:
# - Если символы s1[i-1] и s2[j-1] равны, то d[i][j] = d[i-1][j-1]. Это означает, что не нужно выполнять никакую
# операцию и расстояние между i-й префиксом строки s1 и j-й префиксом строки s2 равно расстоянию между
# (i-1)-й префиксом и (j-1)-й префиксом строк.
# - Иначе, d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1]) + 1, где min() - функция возвращает минимальное
# значение из трех соседних ячеек плюс 1. Это означает, что нужно выбрать минимальное расстояние из трех возможных
# операций: удаление, вставка или замена символа, и добавить единицу, так как выполняется одна операция.
# 6. Выводим значение d[len(s1)][len(s2)], которое и является расстоянием Левенштейна между строками s1 и s2.

s1 = input()
s2 = input()

# создаем матрицу размером (len(s1)+1) x (len(s2)+1) и заполняем ее нулями
d = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]

# заполняем первую строку матрицы значениями от 0 до len(s2)
for i in range(len(s2) + 1):
    d[0][i] = i

# заполняем первый столбец матрицы значениями от 0 до len(s1)
for i in range(len(s1) + 1):
    d[i][0] = i

# заполняем матрицу
for i in range(1, len(s1) + 1):
    for j in range(1, len(s2) + 1):
        if s1[i - 1] == s2[j - 1]:  # если символы равны
            d[i][j] = d[i - 1][j - 1]
        else:
            # минимум из трех соседних ячеек + 1
            d[i][j] = min(d[i - 1][j], d[i][j - 1], d[i - 1][j - 1]) + 1

print(d[len(s1)][len(s2)])
# 2/
# Нахождение расстояния Левенштейна с помощью алгоритма Вагнера-Фишера
# https://www.youtube.com/watch?v=4TgAdLQ9oVY&t=1195s
s1 = input()
s2 = input()


def lev_distance(i, j, s1, s2, matrix):
    if i == 0 and j == 0:
        return 0
    elif j == 0 and i > 0:
        return i
    elif i == 0 and j > 0:
        return j
    else:
        m = 0 if s1[i - 1] == s2[j - 1] else 1
        return min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1, matrix[i - 1][j - 1] + m)


def calculate_levenshtein_distance(s1, s2):
    n = len(s1)
    m = len(s2)
    matrix = [[0 for i in range(m + 1)] for j in range(n + 1)]
    for i in range(n + 1):
        for j in range(m + 1):
            matrix[i][j] = lev_distance(i, j, s1, s2, matrix)
    return matrix[n][m]


print(calculate_levenshtein_distance(s1, s2))


#######################################################################################################
# Наибольшая общая подпоследовательность Мы имеем две последовательности , их общая подпоследовательность длиной
# p — это набор � p индексов при котором Наибольшая общая подпоследовательность — это общая подпоследовательность,
# обладающая самой большой длиной из всех подпоследовательностей.Такая задача может применяться в сопоставлении
# данных (например, утилита � � � � diff, операция слияния в разных системах управления версиями),
# биоинформатике (поиск сходств в генах разных видов) и других сферах.Формат ввода Первая строка: � n.
# Вторая строка: � 1 , � 2 , … , � � a 1​,a 2​,…,a n​. Третья строка: � m. Четвертая строка:
# Ограничения: 1 ≤ � , � ≤ 100 1≤n,m≤100; − 1 0 9 ≤ � � , � � ≤ 1 0 9 −10 9 ≤a i​,b i​≤10 9 для всех � i.
# Формат вывода Выведите длину наибольшей общей подпоследовательности.
# Пример 1 Ввод 5 1 2 5 4 9 8 18 3 2 8 0 4 7 9 Вывод 3 код на питоне
#
# Для решения задачи о наибольшей общей подпоследовательности можно использовать динамическое программирование.
# 1. Создаем двумерный массив dp размерности (n+1) x (m+1), где dp[i][j] будет содержать длину наибольшей общей
# подпоследовательности для префикса a[:i] и b[:j].
# 2. Инициализируем нулевой столбец и нулевую строку массива dp
# нулями, так как подпоследовательность нулевой длины встречается в любой последовательности.
# 3. Заполняем массив dp построчно и постолбцово с помощью следующего алгоритма:
# - Если a[i-1] и b[j-1] совпадают, то dp[i][j] равно dp[i-1][j-1] + 1, так как мы можем увеличить длину наибольшей
# общей подпоследовательности, добавив текущий элемент.
# - В противном случае, dp[i][j] равно максимуму из dp[i-1][j] и dp[i][j-1], так как текущий элемент не входит
# в наибольшую общую подпоследовательность.
# 4. В конце алгоритма dp[n][m] содержит длину наибольшей общей подпоследовательности для всей последовательности a и b.
# 5. Возвращаем значение dp[n][m] в качестве результата.
#
# Для визуализации алгоритма расчета наибольшей общей подпоследовательности можно использовать матрицу,
# где по горизонтали и вертикали расположены элементы двух последовательностей, а в ячейках матрицы указывается длина
# наибольшей общей подпоследовательности для соответствующих элементов.

def longest_common_subsequence(n, a, m, b):
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if a[i - 1] == b[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[n][m]  # угловое максимальное значение внизу справа матрицы


n = int(input())
a = list(map(int, input().split()))
m = int(input())
b = list(map(int, input().split()))

result = longest_common_subsequence(n, a, m, b)
print(result)

###########################################################################################################
# Наибольшая общая подпоследовательность трех последовательностей Имея три последовательности
# Формат ввода Первая строка: � n. Вторая строка:# Третья строка: � m. Четвертая строка:. Пятая строка: � l.
# Шестая строка: # Формат вывода Выведите длину наибольшей общей подпоследовательности трех массивов.
# Пример 1 Ввод 4 1 2 3 4 4 3 2 4 1 3 3 2 4 Вывод 2
# Пример 2 Ввод 3 1 2 4 2 2 4 4 4 2 2 1 Вывод 1
# #Для решения данной задачи можно использовать динамическое программирование. Создадим трехмерный массив dp размером
# (n+1) x (m+1) x (l+1),
# где dp[i][j][k] будет представлять длину наибольшей общей подпоследовательности первых i элементов
# последовательности A, первых j элементов последовательности B и первых k элементов последовательности C.
# Исходное состояние будет dp[0][0][0] = 0, так как пустые последовательности не имеют общих элементов.
# Затем, перебирая элементы последовательностей A, B и C, заполняем массив dp по следующему принципу:
# - Если a[i] = b[j] = c[k], то dp[i][j][k] = dp[i-1][j-1][k-1] + 1. То есть, если текущие элементы всех трех
# последовательностей равны, то увеличиваем длину наибольшей общей подпоследовательности на 1 и переходим к
# предыдущим индексам во всех трех массивах.
# - В противном случае, dp[i][j][k] равно максимуму из трех значений: dp[i][j][k-1], dp[i][j-1][k] и dp[i-1][j][k].
# То есть, если текущие элементы не равны, то длина наибольшей общей подпоследовательности остается такой же,
# как и для предыдущих элементов одной или двух последовательностей.
# В конечном счете, ответ будет содержаться в dp[n][m][l].


n = int(input())
a = list(map(int, input().split()))
m = int(input())
b = list(map(int, input().split()))
l = int(input())
c = list(map(int, input().split()))

dp = [[[0] * (l + 1) for _ in range(m + 1)] for _ in range(n + 1)]

for i in range(1, n + 1):
    for j in range(1, m + 1):
        for k in range(1, l + 1):
            if a[i - 1] == b[j - 1] == c[k - 1]:
                dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1
            else:
                dp[i][j][k] = max(dp[i][j][k - 1], dp[i][j - 1][k], dp[i - 1][j][k])

print(dp[n][m][l])


#######################################################################################################
# Задача о рюкзаке - это классическая задача дискретной оптимизации, которая имеет множество алгоритмов для решения.
# Существуют точные и приближенные алгоритмы для решения этой задачи
# . Некоторые из них включают:
# Полный перебор: Этот алгоритм проверяет все возможные комбинации предметов, чтобы найти оптимальное решение.
# Однако для больших рюкзаков полный перебор может быть вычислительно сложным
# Метод ветвей и подкраживания: Этот алгоритм основан на динамическом программировании и работает следующим образом:
# Разбиваем предметы на небольшие подмножители.
# Для каждого подмножителя определяем оптимальное количество предметов, которое можно положить в рюкзак.
# Затем вычисляем стоимость для каждого подмножителя и выбираем наибольшую стоимость.
# Повторяем процесс для всех подмножителей и выбираем наибольшую стоимость среди всех подмножителей
# .# Жадный алгоритм: Этот приближенный алгоритм выбирает самый дорогой предмет на каждом шаге и добавляет его в
# рюкзак. Он просто и быстро, но не гарантирует оптимальное решение задачи
# 4Динамическое программирование: Этот алгоритм решает задачу путем разделения её на подзадачи и последовательного их
# решения. На каждом шаге алгоритма используются результаты предыдущих шагов для определения оптимального решения
# текущей подзадачи
# В Python можно использовать библиотеку dynamic_programming для решения задачи о рюкзаке, которая предоставляет
# функцию solve для решения задачи с заданными весами и стоимостями предметов.


# Наибольшее количество золота Вы нашли несколько золотых слитков. Ваша цель -- положить как можно больше золота в
# рюкзак с вместимостью � W, то есть в нем можно унести максимум � W фунтов. Каждый слиток только в одном экземпляре,
# вы можете или брать слиток, или нет (нельзя взять часть слитка). Хотя все слитки и выглядят одинаково на рисунке
# выше, они обладают разным весом — он приведен ниже.Формат ввода Первая строка ввода содержит целое число � W
# (вместимость рюкзака) и количество золотых слитков � n. В следующей строке приведены � n целых чисел
# � 1 , … , � � w 1​,…,w n​, которые определяют вес золотых слитков.Ограничения: 1 ≤ � ≤ 1 0 4 1≤W≤10 4 ; 1 ≤
# � ≤ 300 1≤n≤300; 0 ≤ � 1 , … , � � ≤ 1 0 5 0≤w 1​,…,w n​≤10 5 .Формат вывода Максимальный вес золотых слитков,
# который можно уместить в рюкзак со вместимостью � W.код на питоне и алгоритм решения
# Алгоритм решения задачи можно построить с использованием динамического программирования.
#
# 1. Создайте двумерный массив dp размером (n+1) x (W+1), где каждый элемент dp[i][j] будет хранить максимальный вес
# золотых слитков, который можно уместить в рюкзаке емкостью j, используя только первые i слитков.
# 2. Инициализируйте первую строку dp[0][j] равными нулю, так как без слитков рюкзак будет пуст.
# 3. Инициализируйте первый столбец dp[i][0] равным нулю, так как в пустой рюкзак нельзя положить никакие слитки.
# 4. Заполните оставшиеся значения массива dp по следующим правилам:
#    - Если вес слитка weights[i - 1] больше j, то dp[i][j] = dp[i-1][j] (нельзя положить слиток i в рюкзак).
#    - Иначе, dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + w[i]) (максимум из случаев, когда слиток i не положен в
#    рюкзак и когда он положен в рюкзак, учитывая оставшуюся вместимость).
# 5. Верните значение dp[n][W] - это будет максимальный вес золотых слитков, который можно уместить в рюкзаке
# вместимостью W.
#
# Функция `max_gold_weight` принимает на вход вместимость рюкзака `W` и список весов предметов `weights`.
# Она возвращает максимальный вес золота, который можно унести в рюкзаке.# Переменная `n` хранит количество предметов.
# Создается двумерный массив `dp` размером `(n+1) x (W+1)`, инициализированный нулями. В этом массиве будут
# храниться значения максимального веса золота для всех подзадач.# Затем происходит двойной цикл `for`, в котором
# заполняется массив `dp`. На каждой итерации внешнего цикла рассматривается предмет с номером `i`, а во внутреннем
# цикле рассматривается вместимость рюкзака `j`. Если вес текущего предмета `weights[i-1]` больше текущей вместимости
# `j`, то значение `dp[i][j]` берется из предыдущей строки `dp[i-1][j]`. Иначе, выбирается максимальное значение из
# предыдущей строки `dp[i-1][j]` и суммы значения из предыдущей строки `dp[i-1][j - weights[i-1]]` и веса текущего
# предмета `weights[i-1]`. Полученное максимальное значение записывается в ячейку `dp[i][j]`.# В конце функция
# возвращает значение в ячейке `dp[n][W]`, которое является максимальным весом золота, который можно унести в
# рюкзаке в пределах вместимости `W`.# print(MemoizedKnapsack(W, weights))

def max_gold_weight(W, weights: list):
    n = len(weights)
    dp = [[0] * (W + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):  # предмет с номером `i`
        for j in range(1, W + 1):  # вместимость рюкзака `j`
            if weights[i - 1] > j:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + weights[i - 1])

    return dp[n][W]


W, n = map(int, input().split())
weights = list(map(int, input().split()))

print(max_gold_weight(W, weights))

###########################################################################################################
# Распределение сувениров Три пирата делят свою добычу, в которую входят � n предметов разной ценности.
# Получится у вас помочь разделить добычу поровну?Формат ввода Первая строка содержит целое число � n.
# Вторая строка содержит целые числа � 1 , � 2 , … , � � v 1​,v 2​,…,v n​, разделенные пробелами.
# Ограничения: 1 ≤ � ≤ 20 1≤n≤20, 1 ≤ � � ≤ 30 1≤v i​≤30 для всех � i.Формат вывода Вывести 1, если � 1 , � 2 ,
# … , � � v 1​,v 2​,…,v n​можно разделить на три поднабора с одинаковыми суммами; в противном случае —
# вывести 0.

def can_split(v):
    total_sum = sum(v)  # Вычисляем сумму всех элементов списка
    if total_sum % 3 != 0:  # Если сумма не делится на 3 без остатка, то разделить нельзя
        return 0
    V = total_sum // 3  # Вычисляем сколько должно быть в каждой трети суммы
    n = len(v)  # Количество элементов в списке

    # Создаем трехмерный массив для хранения информации о возможности разделения
    split = [[[0 for _ in range(V + 1)] for _ in range(V + 1)] for _ in range(n + 1)]

    split[0][0][0] = 1  # В начале ни один элемент не используется, поэтому все значения равны False

    # Проходим по всем элементам списка и заполняем массив split
    for i in range(1, n + 1):
        for s1 in range(V + 1):
            for s2 in range(V + 1):
                split[i][s1][s2] = split[i - 1][s1][s2]  # Значение split[i][s1][s2] равно значению split[i-1][s1][s2]
                if s1 >= v[i - 1]:
                    split[i][s1][s2] |= split[i - 1][s1 - v[i - 1]][s2]
                    # Значение split[i][s1][s2] может быть True, если значение split[i-1][s1-v[i-1]][s2] также True
                if s2 >= v[i - 1]:
                    split[i][s1][s2] |= split[i - 1][s1][s2 - v[i - 1]]
                    # Значение split[i][s1][s2] может быть True, если значение split[i-1][s1][s2-v[i-1]] также True

    return split[n][V][V]
    # Возвращаем значение split[n][V][V], которое показывает, можно ли разделить список на 3 трети с одинаковой суммой

# n = int(input())
# v = list(map(int, input().split()))
n = 5
v = [1, 1, 2, 2, 1]
result = can_split(v)
print(result)

#######################################################################################################
###########################################################################################################
def exchange(money):
    coins = [1, 5, 10, 20, 50]
    num_coins = [0] * (money + 1)
    used_coins = [[] for _ in range(money + 1)]

    for m in range(1, money + 1):
        min_coins = float('inf')
        for coin in coins:
            if m >= coin and num_coins[m - coin] + 1 < min_coins:
                min_coins = num_coins[m - coin] + 1
                used_coins[m] = used_coins[m - coin] + [coin]
        num_coins[m] = min_coins

    return num_coins[money], *used_coins[money]


n = int(input())
count, *coins = exchange(n)
print(count)
print(*coins)


################################################################
# 2.
def exchange(money):
    coins = [1, 5, 10, 20, 50]
    prev_num_coins = [0] * (money + 1)
    curr_num_coins = [0] * (money + 1)
    used_coins = [[] for _ in range(money + 1)]

    for m in range(1, money + 1):
        min_coins = float('inf')
        for coin in coins:
            if m >= coin and prev_num_coins[m - coin] + 1 < min_coins:
                min_coins = prev_num_coins[m - coin] + 1
                used_coins[m] = used_coins[m - coin] + [coin]
        curr_num_coins[m] = min_coins
        prev_num_coins = curr_num_coins[:]

    return curr_num_coins[money], *used_coins[money]


n = int(input())
count, *coins = exchange(n)
print(count)
print(*coins)
# 3.

########################################################################
# удалить все вхождения val и вернуть длину массива
numbers = ['1', '2', '3', '1', '5', '1', '1', '8', '9']

print(numbers)
# 1    O(n)
res = []
val = '1'
for i in numbers:
    if i != val:
        res.append(i)
print(res)

# 2  O(n2)
for i in range(len(numbers)):
    i = 0
    while i < len(numbers):
        if numbers[i] == val:
            del numbers[i]
            continue
        else:
            i += 1
print(numbers)
# 3 в худшем случае O(n)

start = 0
end = len(numbers) - 1
mid = 0
while mid < end:
    if numbers[mid] != val:
        numbers[start], numbers[mid] = numbers[mid], numbers[start]
        start += 1
        mid += 1
    else:
        mid += 1

print(start)


# связные списки

class Node:
    def __init__(self, value=None, next=None):
        self.value = value
        self.next = next

    def __str__(self):
        return self.value


def insert_node(node, index, value):
    head = node
    new_node = Node(value)
    if index == 0:  # если index=0 вставляем в начало
        new_node.next = None
        return new_node
    while index - 1 != 0:
        node = node.next
        index -= 1

    tmp = node.next
    node.next = new_node
    new_node.next = tmp
    return head


# n1->n2->n3->None
n3 = Node('third')
n2 = Node('second', n3)
n1 = Node('first', n2)

print(n1)  # first
print(n2)  # second
print(n3)  # third

# insert a new node in position 2
node, index, value = n1, 2, 'new_node'
head = insert_node(node, index, value)
print(head)  # first
print(head.next)  # second
print(head.next.next)  # new_node

################################################################
from queue import Queue


class Queue:
    def __init__(self, n):
        self.queue = [None for _ in range(n)]
        self.max = n
        self.head = self.tail = self.size = 0

    def is_empty(self):
        return self.size == 0

    def put(self, x):  # добавлкение в конец
        if self.size != self.max:
            self.queue[self.tail] = x
            self.tail = (self.tail + 1) % self.max  # %self.max чтобы зациклить список певый идёт после последнего
            self.size += 1

    def get(self):  # возврат из начала
        if self.is_empty():
            return None
        x = self.queue[self.head]
        self.queue[self.head] = None
        self.head = (self.head + 1) % self.max  #
        self.size -= 1
        return x


q = Queue(3)
q.put(1)
print(q.queue)  # [1, None, None]
q.put(2)
print(q.queue)  # [1, 2, None]
print(q.get())  # 1
print(q.queue)
q.put(3)
print(q.queue)  # [None, 2, 3]
q.put(4)  # уходит в начало списка т.к. список зациклен
print(q.queue)  # [4, 2, 3]
print(q.get())  # 2
print(q.queue)  # [4, None, 3]


################################################################

# ____2. Основные структуры данных__
# связные списки
# функция def swapNodes(self): меняет местами каждые два соседних узла
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = self.tail = None

    def insert(self, node):
        if self.head is None:
            self.head = node
        if self.tail is not None:
            self.tail.next = node
            self.tail = None
        self.tail = node

    def get_data(self):
        lst = []
        h = self.head
        while h:
            lst.append(h.value)
            h = h.next
        return lst

    def swapNodes(self):
        lst = self.get_data()
        # if lst[1]:
        for i in range(0, len(lst) - 1, 2):
            tmp = lst[i + 1]
            lst[i + 1] = lst[i]
            lst[i] = tmp
        return lst


lst = LinkedList()
lst.insert(Node(1))
lst.insert(Node(2))
lst.insert(Node(3))
lst.insert(Node(4))
lst.insert(Node(5))
print(*lst.get_data())  # 1 2 3 4 5
res = lst.swapNodes()
print(res)  # [2, 1, 4, 3, 5]
################################################################
# раскодировать строку n -кол-во повторений символов

string = '3[a2[b]]'  # a b b a b b a b b


# string = '2[a]3[bc]1[d]'

def dec(string):
    l = []
    for i in range(len(string) - 1):
        if string[i] not in ('[', ']', ''):
            l.append(string[i])
    # print(*l)  # 3 a 2 b
    s = ''
    for i in range(-1, -len(l) - 1, -1):  # -1,-4
        if l[i].isdigit():
            s = int(l[i]) * s
        if l[i].isalpha():
            s = l[i] + s
    return s


print(*dec(string))  # a b b a b b a b b
################################################################
string = '2[a]3[bc]1[d]'  # a a b c b c b c d


def dec(string):
    l = []
    for i in range(len(string) - 1):
        if string[i] not in ('[', ']', ''):
            l.append(string[i])
    # print(*l)  # 2 a 3 b c 1 d
    s = ''
    tmp = 0
    for i in range(-1, -len(l) - 1, -1):  # -1,-4
        if l[i].isdigit():
            s = (int(l[i]) - 1) * s[0:tmp] + s
            tmp = 0
        else:
            s = l[i] + s
            tmp += 1
    return s


print(*dec(string))  # a a b c b c b c d
################################
# 1_____смешать поочерёдно плейлист
id_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
id_2 = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
lst = []
# for i in zip(id_1, id_2):
#     lst.append(i[0])
#     lst.append(i[1])
for i, j in zip(id_1, id_2):
    lst.extend([i, j])
print(*lst)
################################
from itertools import chain  # модуль itertools для создания собственных итераторов


# Объединить несколько списков в один  itertools.chain(*iterables) Функция chain() модуля itertools создает итератор,
# который возвращает элементы из первой iterables, пока она не будет исчерпана, а затем переходит к
# следующей iterables, пока все итерируемые последовательности не будут исчерпаны.
# эквивалентна следующему коду:
# def chain(*iterables):
#     # chain('ABC', 'DEF') --> A B C D E F
#     for it in iterables:
#         for element in it:
#             yield element


def main():
    mix = chain(*zip(id_1, id_2))
    print(mix)  # <itertools.chain object at 0x0000025ED68DB730>
    print(' '.join(map(str, mix)))  # 1 11 2 12 3 13 4 14 5 15 6 16 7 17 8 18 9 19 10 20


# str.join(iterable) iterable - итерируемый объект с элементами в виде строк.

if __name__ == '__main__':
    main()


# Вызов функции main(): В конце скрипт проверяет, является ли этот модуль главным, и если да, то вызывает функцию main().
# Это обеспечивает, что функция main() будет вызвана, только если этот скрипт запущен напрямую, а не импортирован как
# модуль в другой скрипт. Если этот скрипт импортирован, функция main() не будет вызвана автоматически.

################################
def main():
    with open('input.txt') as f:
        _ = f.readline
        rus = f.readline().split()
        foregion = f.readline().split()
        mix = chain(*zip(rus, foregion))
        print(' '.join(mix))


if __name__ == '__main__':
    main()
########################################################################
# В Python существует несколько способов перевернуть строку. Рассмотрим некоторые из них:

# 1. Используя срезы (slicing):

string = "Hello, World!"
reversed_string = string[::-1]
print(reversed_string)

# # 2. Используя функцию `reversed()` и метод `join()`:
string = "Hello, World!"
reversed_string = ''.join(reversed(string))
print(reversed_string)

# 3. Используя цикл:

string = "Hello, World!"
reversed_string = ''
for char in string:
    reversed_string = char + reversed_string
print(reversed_string)  # Результат также будет "!dlroW ,olleH"
# развернуть строку

string = '12345678-9'
print(list(range(len(string) - 1, -1)))  # range(8, -1) -> []


def main(string):
    temp = ''
    for i in range(len(string) - 1, -1, -1):
        temp += string[i]
    return temp


if __name__ == '__main__':
    print(main(string))  # 987654321


##################
def reversed1(variable):
    res = []
    for i in range(len(variable) - 1, -1, -1):
        res.append(variable[i])
    res = ''.join(res)
    return res


n = reversed1(input())
print(n)
########################
str = "pythonist"  # исходная строка
reversedString = []
index = len(str)  # вычисляем длину строки и сохраняем ее в переменной index
while index > 0:
    reversedString += str[index - 1]  # сохраняем значение str[index-1] в reverseString
    index = index - 1  # уменьшаем значение index на 1
print(reversedString)  # перевернутая строка


######################
# Рекурсия Начну объяснение с конца. Если мы записали в результат все символы кроме первого, то длина оставшейся строки
# равна единице и, следовательно, ее нужно вернуть. Получаем:Но если длина строки больше одного, то нужно вернуть
# последний из ее элементов и вызвать эту же функцию, но уже отрезав последний символ. Сделать это мы можем с помощью
# среза variable[:-1]
def reversed3(variable):
    if len(variable) == 1:
        return variable
    return variable[-1] + reversed3(variable[:-1])


n = reversed3(input())
print(n)
################################################################
n = input()[::-1]  # перебираем символы с шагом -1, то есть в обратном порядке.
print(n)
###########
# развернуть строку

string = '123456789'


def main(string):
    temp = ''
    for i in range(1, len(string) + 1):
        temp += string[-i]
    return temp


if __name__ == '__main__':
    print(main(string))  # 987654321
########################################################
# 2__развернуть число numbers = '1-223-40' (если 0 в начале - не писать, учитывая отрицательные числа)

# numbers = str(input('Number: '))
# numbers = '1-223-40'
# numbers = list(numbers)

# numbers = list(map(str, input('Numbers: ').split()))
numbers = input('Numbers: ').split()  # ->list()


def main(n):
    if n in ('', '0'):
        return n
    i = 0
    while True:  # развернуть '-'
        try:
            if n[i] == '-':
                n[i], n[i + 1] = n[i + 1], n[i]
                # if n[i] == n[-1]:
                #     break
                i += 2
            i += 1
        except IndexError:
            break
    print(''.join(reversed(n)).lstrip('0'))  # -432-21


# reversed(seq) - Возвращаемое значение:обратный итератор. <reversed object at 0x0000028A30F7BC70>
# недостаточно написать res = reversed(variable), данные нужно преобразовать в нужный тип (в нашем случае - в строку).
# Сделать мы это можем при помощи метода join()
if __name__ == '__main__':
    main(numbers)


################################
# нужно по возрастанию в одной строке вывести пропущенные числа # 7 первая строка
# 6 4 1 2 3 - вторая строка.
# 7
# 6 4 1 2 3
def find_two_missing_numbers(n_1: int, n_2: map):
    """if need to optimize memory,  can do with XOR O(1) memory
    -без доп памяти (если число XOR-рить само с собой.всегда-> 0 и XOR-рить то получим пропущенную последовательность"""
    all_nums = set(range(1, n_1 + 1)) - set(n_2)  # {1, 2, 3, 4, 5, 6, 7}
    # создаем множество всех чисел от 1 до максимального числа в исходном списке. Использование множества обеспечивает
    # эффективность выполнения операции вычитания, так как оно удаляет все повторяющиеся элементы и обеспечивает
    # быстрый доступ к данным. вычитаем из первой строки вторую с помощью множества
    return all_nums


def main():
    with open('text.txt', 'r') as f:
        n_1 = int(f.readline().strip())
        n_2 = map(int, f.readline().split())
        n_missing = find_two_missing_numbers(n_1, n_2)
        print(*n_missing)  # 5 7


if __name__ == ('__main__'):
    main()


################################################################
def find_two_missing_numbers(n_1: int, n_2: map):
    all_missing_nums = set(range(1, n_1 + 1))
    for i in n_2:
        all_missing_nums.remove(i)
    return all_missing_nums


def main():
    with open('text.txt', 'r') as f:
        n_1 = int(f.readline().strip())
        n_2 = map(int, f.readline().split())
        n_missing = find_two_missing_numbers(n_1, n_2)
        print(*n_missing)  # 5 7


if __name__ == ('__main__'):
    main()
################################################################
# нужно по возрастанию в одной строке вывести пропущенные числа n_1
n_1 = 7
n_2 = 6, 4, 1, 2, 3  # tuple


def find_two_missing_numbers(n_1: int, n_2):
    all_nums = set(range(1, n_1 + 1)) - set(n_2)
    return all_nums


def main(n_1: int, n_2):
    # with open('text.txt', 'r') as f:
    # n_1 = int(f.readline().strip())
    # n_2 = map(int, f.readline().split())
    n_missing = find_two_missing_numbers(n_1, n_2)
    print(*n_missing)  # 5 7


if __name__ == ('__main__'):
    main(n_1, n_2)
################################################################
# Этот алгоритм использует свойство операции XOR (исключающее ИЛИ) для нахождения двух пропущенных чисел. Вот как он
# работает:Вычисление XOR всех чисел от 1 до n и всех чисел в списке: В этом шаге алгоритм изначально закладывается на
# идею, что если мы выполним операцию XOR для двух одинаковых чисел, мы получим 0. Если мы выполним XOR для всех чисел
# от 1 до n и всех чисел в списке, то числа, которые присутствуют и в диапазоне, и в списке, исключат друг друга
# (т.е. дадут в результате 0), оставив нам XOR-значения только для пропущенных чисел.Пример:Рассмотрим список чисел
# [1, 2, 4] с n = 5. XOR всех чисел от 1 до n (1^2^3^4^5=1) и всех чисел в списке (1^2^4=7) даст 7^1, что равно 6.
# 6 в двоичном представлении — это 110, что представляет собой XOR от 2 и 4 (двух пропущенных чисел).Нахождение любого
# 'set bit': Далее алгоритм ищет любой 'set bit' (бит, установленный в 1) в полученном XOR. 'set bit' можно найти как
# XOR & ~(XOR - 1), где ~ это оператор НЕ (инверсия битов). Бит, установленный в 1, отличает два пропущенных числа,
# то есть одно число имеет этот бит равный 1, а другое — 0.Пример:Пусть XOR равно 6 (110 в двоичном виде). Получим
# 'set bit' как 110 & ~(110 - 1) = 110 & ~(101) = 110 & 010 = 010 (второй бит — это 'set bit').Разделение чисел на
# две группы и нахождение XOR в каждой группе: Начиная с набора чисел от 1 до n и списка, алгоритм делит числа на две
# группы: те, у которых 'set bit' установлен в 1, и те, у которых 'set bit' равен 0. Затем вычисляются XOR-значения в
# каждой группе, оставляя в каждой группе XOR только одного пропущенного числа.Пример:Числа от 1 до 5 можно разделить
# на две группы: [1, 3, 5] (у которых второй бит равен 0) и [2, 4] (у которых второй бит равен 1). Затем вычислим XOR
# для каждой группы как 1^3^5=3 и 2^4=6. Теперь, если мы сделаем то же самое для списка [1, 2, 4], мы получим XOR
# групп как 1 и 6. Наконец, XOR для значений в каждой группе даст нам пропущенные числа: 3^1=2 и 6^6=0.
# Итак, в конечном итоге этот алгоритм выделяет два отсутствующих числа: 2 и 0.
################################
# нужно по возрастанию в одной строке вывести пропущенные числа n_1
n_1 = 7
n_2 = 6, 4, 1, 2, 3  # tuple
from typing import List


def find_two_missing_numbers(nums: List[int], n: int) -> List[int]:
    # Вычисление XOR всех чисел от 1 до n и всех чисел в списке
    xor = 0
    for i in range(1, n + 1):
        xor ^= i
    for num in nums:
        xor ^= num

    # Нахождение любого 'set bit'
    set_bit = xor & ~(xor - 1)

    # Разделение чисел на две группы и нахождение XOR в каждой группе
    missing_nums = [0, 0]
    for i in range(1, n + 1):
        if i & set_bit:
            missing_nums[0] ^= i
        else:
            missing_nums[1] ^= i
    for num in nums:
        if num & set_bit:
            missing_nums[0] ^= num
        else:
            missing_nums[1] ^= num

    return missing_nums


print(*find_two_missing_numbers(n_2, n_1))
################################
# в первой строке n бактерий. В следующих n строках 4 числа:номер бактерии, количество прожитых часов, номера двух её
# потомков. Если номер потомка -1 значит нет потомка. Нужно вывести среднюю продолжительность жизни на каждом уровне, до
# двух знаков после запятоой
from collections import defaultdict


# 7
# 1 1 2 3
# 2 2 4 5
# 3 3 6 -1
# 4 4 7 -1
# 5 5 -1 -1
# 6 6 -1 -1
# 7 7 -1 -1

def main():
    levels_to_weight = defaultdict(list)
    levels = []  # 0 1 1 2 2 2 3
    parents = {}  # {1:0,2:0,3:1,4:1,5:2,6:3}
    with open('text.txt') as f:
        n = int(f.readline().strip())  # 1-я строка кол-во всех бактерий
        for i in range(n):
            _, h, a, b = map(int, f.readline().split())  # _ -№ бактерии игнорируется т.к тспользуем i вместо №,
            # h-часы, a, b - № потомков
            if i != 0:  # Если бактерия не является корневой (т.е. i != 0), уровнем бактерии становится уровень ее
                # родителя, увеличенный на 1.
                lvl = levels[parents[i]] + 1  # номер уровня для текущей бактерии i
                levels.append(lvl)  # levels будет хранить уровень для каждой бактерии (где уровень родительской
                # бактерии переносится на всех её потомков).
                # И также levels - это список, где каждому элементу соот. уровень (level) бактерии с тем же индексом.
            # Таким образом, для текущей бактерии с номером i, parents[i] дает номер ее родительской бактерии.
            # Выражение levels[parents[i]] используется для получения уровня (level) родительской бактерии, а затем
            # прибавляется 1, чтобы получить уровень текущей бактерии.В итоге, lvl будет содержать уровень бактерии i,
            # который затем используется для сохранения информации о средней продолжительности жизни на каждом уровне.
            else:  # root level
                lvl = 0
                levels.append(lvl)  # список, где каждому элементу соответствует уровень (level) бактерии с тем же индек

            levels_to_weight[lvl].append(h)  # dict{ lvl : h....} где ключами являются уровни, добавляется
            # продолжительность жизни каждой бактерии.т.е. кол-во часов для данного уровня [1,2,3...]
            if a != -1:
                parents[a - 1] = i  # записи о этих потомках и их родителе. словарь, в котором ключами являются номера
            # потомков, а значениями - номера их родительских бактерий.
            #  используете переменную i для указания родительской бактерии
            #  (т.е. текущую бактерию в текущей итерации), и a и b - номера её потомков.
            #  бактерия с номером a - 1 имеет родителя i. Вычитание 1 из a в a - 1 связано с тем, что в Python
            #  индексация элементов начинается с 0, а не с 1, а по условию задачи бактерии нумеруются начиная с 1.
            if b != -1:
                parents[b - 1] = i

    for lvl, weight in levels_to_weight.items():
        avl_weight = sum(weight) / len(weight)
        print(f'{avl_weight:.2f}', end=' ')


if __name__ == '__main__':
    main()

################################################################
# НАйти сымый часто встречающийся смимвол в строке, если несколько символов встречаются одинаковло часто вывести любой
# 1. O(n^2)
string = 'abaaba'

count = 0
simbol = ''
for i in range(len(string)):
    cur = 0
    for j in range(len(string)):
        if string[i] == string[j]:
            cur += 1
            if cur > count:
                count = cur
                simbol = string[j]

print(simbol)  # a

# 2. O(n^2)
string = 'abaaba'
s = string
print(max(map(lambda x: (s.count(x), x), s))[1])  # a
# lambda, которая возвращает пару значений: количество вхождений этого элемента в строку s (s.count(x)) и сам элемент
# x. map возвращает итератор со всеми этими парами значений.max(...) - мы выбираем максимальное значение из всех пар
# значений. Если есть две или более пар со значением подсчета, равным максимальному, выбирается та, которая встречается
# позже, потому что max возвращает последнее максимальное значение в случае равенства.
# [1] at the end of the expression is used to access the second item of the returned tuple, which is the character
print(max(map(lambda x: (s.count(x), x), s)))  # (4, 'a')
# Если бы вы хотели сортировать по количеству повторений, но в обратном порядке,
# вы бы использовали key=lambda x: -int(x[0]). Однако, в данном контексте это не требуется.

# 3.
# НАйти сымый часто встречающийся смимвол в строке, если несколько символов встречаются одинаковло часто вывести любой
# O(N+K) k<N -> O(N)
string = 'ccafffxxvvvvvvvxxccc'
d = dict()
max_simbol = ''
max_cur = 0
for i in string:
    # mac_cur = 0
    if i not in d:
        d[i] = 0
    d[i] += 1

for key in d:
    if d[key] > max_cur:
        max_cur = d[key]
        max_simbol = key
print(d)  # {'c': 5, 'a': 1, 'f': 3, 'x': 4, 'v': 7}
print(max_simbol)  # v
################################################
d = dict()
max_simbol = ''
max_cur = 0
for i in string:
    if i not in d:
        d[i] = 0
    d[i] += 1

    if d[i] > max_cur:
        max_simbol = i
        max_cur = d[i]


################################
# 1. дана последовательность чисел ,найти первое левое положитеольное вхождение числа или вывести -1 если его нет
def function(seq, x):
    ans = -1
    for i in seq:
        if ans == -1 and i == x: ans = i
    return num


################################
# 2.
def function(seq, x):
    for i in seq:
        if ans == -1 and i == x: return i
    return -1


# 1. дана последовательность чисел ,найти последнее (правое) вхождение числа или вывести -1 если его нет
def function(seq, x):
    ans = -1
    for i in range(len(seq)):
        if seq[i] == x:
            ans = seq[i]
    return ans


# 2 Дана последовательность  чисел длиной N>0.Найти максимаьное число
import math


def func(seq):
    # ans = -math.inf
    ans = seq[0]
    for i in range(1, len(seq)):
        if seq[i] > ans:
            ans = seq[i]
    return ans


################################################################
# 3 Дана последовательность  чисел длиной N>0.Найти максимаьное число
# более универсальный чтобы не пришлось копировать каждый раз в случае если будут использоваться строки,
# т.к. это займёт больше времени для других языков кроме Питона
# поэтому использовать ссылку на индекс объекта
def func(seq):
    ans = 0  # index sequence
    for i in range(1, len(seq)):
        if seq[i] > seq[ans]:
            ans = i
    return seq[ans]


################################################################
# Дана последовательность  чисел длиной N>1. Найти макс число и второе по величине (такое кот будет макс
# если вычеркнуть из последовательности одно максимальное число)
# 1. O(n) / O(1) memory меньше всего из других вариантов
# задать первые 2 эл. макс1 и макс2 ->перебрать последовальность начиная с 3 эл. сравнивая с макс1 и макс2
def largest_two(seq):
    max_1 = max(seq[0], seq[1])
    max_2 = min(seq[0], seq[1])
    for i in range(2, len(seq)):
        if max_1 < seq[i]:
            max_2 = max_1
            max_1 = seq[i]
        elif max_2 < seq[i]:  # если вместо elif написать if то после первого if (if max_1 < seq[i]:)
            # max_2 сдесь перезапишется
            max_2 = seq[i]
    return max_1, max_2


################################
def largest_two(seq):
    max_1, max_2 = seq[:2]
    if max_1 < max_2:
        max_1, max_2 = max_2, max_1
    for i inn in range(2, len(seq)):
        if seq[i] > max_1:
            max_1, max_2 = seq[i], max_1
        elif seq[i] > max_2:
            max_2 = seq[i]
    return max_1, max_2


################################################################
# 2 . Найти макс1 скопировать список- удалить оттуда макс1 - найти там макс2
def double_two(seq):
    max_1 = max(seq)
    # copy_lst = list(seq)
    copy_lst = seq.copy()
    copy_lst.remove(max_1)
    return max_1, max(copy_lst)


################################
# 3. найти макс1 и его индекс - убрать его найти макс2 и вставить обратно макс1 прежний индекс
def mutable_two(seq):
    ind = max(range(len(seq)), key=seq.__getitem__)  # в key передаются индексы от range->0,1,2,.. идёт обращение в
    # seq.__getitem__ по индексу ч/з __getitem__ для того чтобы перебрать seq[i] и из значений seq выбрать индекс
    # соответсвующий макс элементу, т.е. вернёт индекс
    max_1 = seq[ind]
    del seq[ind]
    # seq.remove(max_1)
    max_2 = max(seq)
    seq.insert(ind, max_1)  # обратно вернули значение
    return max_1, max_2


################################
# 4.создать новый отсортированный список и взять 2 крайних значения
def sorting_two(seq):
    return tuple(sorted(seq, reverse=True)[:2])


################################
def sorting_two(seq):
    return tuple(sorted(seq)[-2:])


################################
def find_max_and_second_max(arr):
    if len(arr) < 2:
        return None, None

    max_num = float('-inf')  # неправильно если пустой [] то выдаст float('-inf')
    second_max_num = float('-inf')

    for num in arr:
        if num > max_num:
            second_max_num = max_num
            max_num = num
        elif num > second_max_num and num < max_num:
            second_max_num = num

    return max_num, second_max_num


################################################################
# Дана последовательность  чисел длиной N. Найти мин чётное число в последовательности или вывести -1,если егоdef

def f(seq):
    ans = -1
    for i in range(len(seq)):
        if seq[i] % 2 == 0 and (ans == -1 or ans > seq[i]):
            ans = seq[i]
    return ans


################################################################

def f(seq):
    ans = -1
    flag = False
    for i in range(len(seq)):
        if seq[i] % 2 == 0 and (not flag or ans > seq[i]):
            ans = seq[i]
            flag = True
    return ans


################################################################
def find_min_even_number(sequence):
    min_even = float('inf')  # Используем бесконечность как начальное значение минимального четного числа

    for num in sequence:
        if num % 2 == 0 and num < min_even:
            min_even = num

    if min_even == float('inf'):
        return -1
    else:
        return min_even


################################################################
# Дана последовательность  слов . Вывести самые короткие через пробел
seq = 'Дана ff последовательность  слов ff Вывести ff aa bb самые короткие через пробел'


def f(string):
    seq = string.split()
    ans = [0]
    for i in range(1, len(seq)):
        if len(seq[i]) < len(seq[ans[0]]):
            ans = [i]
        elif len(seq[i]) == len(seq[ans[0]]):
            ans.append(i)
    return (seq[i] for i in ans)


print(*f(seq))  # ff ff ff aa bb


################################################################`
##2.
def f(string):
    seq = string.split()
    ans = [seq[0]]
    for i in range(1, len(seq)):
        if len(seq[i]) < len(ans[0]):
            ans = [seq[i]]
        elif len(seq[i]) == len(ans[0]):
            ans.append(seq[i])
    return ' '.join(ans)


print(f(seq))  # ff ff ff aa bb
################################################################
# 3/
# Дана последовательность  слов . Вывести самые короткие через пробел
seq = 'Дана ff слов ff Вывести ff aa bb '


def f(string):
    seq = string.split()
    min_len = len(seq[0])
    for i in seq:  # найти мин длину слов
        if len(i) < min_len:
            min_len = len(i)
    ans = []
    for j in seq:
        if len(j) == min_len:
            ans.append(j)

    return ' '.join(ans)


print(f(seq))


############################################################ ####
# В двумерном мире из блоков 1х1 метр. Остров - набор столбцов  состоящий из блоков. Над островом прошёл дождь
# и заполнил низины, сколько воды (блоков) осталось заполненными водой

def isleflood(h):
    # найти макс позицию и поделим остров пополам
    max_pos = 0
    for i in range(len(h)):
        if max_pos < h[i]:
            max_pos = i
    ans = 0
    now_max = 0
    # обойти обе половинки острова
    for i in max_pos:
        if now_max < h[i]:
            now_max = i
            ans += now_max - h[i]  # вычитаем и получаем пустые пространства занятые водой
    now_max = 0
    # теперь обход справа на лево в обратку
    for i in range(len(h - 1), max_pos, -1):
        if now_max < h[i]:
            now_max = i
            ans += now_max - h[i]
    return ans


################################################################
# Дана строка состоящая из букв A-Za-z. Написать функцию RLE которая на выходе даст ANBM..(N-кол-во повторений А
# M-КОЛ-во повторов B если символ встречается более одного раза к нему добавляется ко-во повторов) и сгенерит ошибку
# если пришла невалидная строка
# 1.
string = 'eAADDC'


def func(string):
    d = {i: 0 for i in set(string)}
    for i in string:
        d[i] += 1
    v = []
    for i in d.items():
        if i[1] == 1:
            v.append(i[0])
        else:
            v.append(i[0] + str(i[1]))
    return ''.join(v)


print(func(string))


################################################################
def func(string):
    d = {i: 0 for i in set(string)}
    for i in string:
        d[i] += 1
    lst = []
    for k, v in d.items():
        if v == 1:
            lst.append(''.join([k]))
        else:
            lst.append(''.join([k, str(v)]))
    return ''.join(lst)


################################
def rle(s):
    d = {}
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] += 1
    result = ''  # строку лучше не использовать т.к будет увечение времени алгоритма из-за того что она будет при каждом
    # проходе создаваться заново, лучше list
    for k, v in sorted(d.items(), key=lambda x: x[1]):  # сортировка по возрастанию значений
        # dict_items([('e', 4), ('A', 2), ('D', 2), ('C', 1)])
        if v == 1:
            result += k
        else:
            result += k + str(v)
    return result


################################################################
# не совсем верно если символы повторяются далее по тексту
string = 'eeAADDCee'


def rle(string):
    def pack(string, count):
        if count > 1:
            return string + str(count)
        return string  # если один символ то не пишем 1

    lastsym = string[0]
    last_pos = 0
    ans = []
    for i in range(len(string)):
        if string[i] != lastsym:
            ans.append(pack(lastsym, i - last_pos))  # i - last_pos -кол-во символов подряд
            last_pos = i
            lastsym = string[i]

    ans.append(pack(string[last_pos], len(string) - last_pos))
    return ''.join(ans)


print(rle(string))  # e2A2D2Ce2
################################################################
# проверить сможет ли кирпич размерами axbxc м  пролезти в проём размером dxe м.

a = 3
b = 2
c = 1
d = 5
e = 4
l = [c, b, a]
min_n = 0
for i in range(len(l) - 1):
    for j in range(len(l) - 1 - i):
        if l[j] > l[j + 1]:
            l[j], l[j + 1] = l[j + 1], l[j]

a, b = l[:2]
# d, e = (d, e) if d < e else (e, d)
# Это приводит к ошибке, потому что в Python оператор if имеет меньший приоритет, чем оператор присвоения (=). Однако,
# есть два возможных варианта корректного использования этого выражения:# Использовать скобки для каждого из кортежей:
# d, e = (d, e) if d < e else (e, d)
# Или использовать только один набор скобок:# (d, e) = d, e if d < e else e, d
# Оба этих варианта корректно работают, так как они задают необходимые приоритеты и соблюдают правило Python о
# распаковке значений.

d, e = (d, e) if d < e else (e, d)
print(d, e)
if a <= d and b <= e:
    print('yes')
else:
    print('no')
################################################################
import itertools


def check_brick_fit(a, b, c, d, e):
    # itertools.permutations([a, b, c], 3) автоматически создаст все возможные перестановки размеров кирпича.
    # Функция permutations() модуля itertools возвращает итератор с последовательными перестановками из элементов
    # входной последовательности iterable. Каждая комбинация заключена в кортеж с длинной r элементов.
    # Если r не указано или None, тогда по умолчанию r равна длине iterable и генерируются все возможные
    # перестановки полной длины.
    # Количество возвращенных сочетаний равно n! / (n-r)! если 0 <= r <= n или ноль если r > n.
    # orientations = [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]
    orientations = list(itertools.permutations([a, b, c], 3))

    for i in orientations:  # Проверяем, сможет ли кирпич пролезть в проём по каждой оси
        if i[0] <= d and i[1] <= e:
            return True
    return False


brick_size = (a, b, c)  # Размеры кирпича [3,2,1]
opening_size = (d, e)  # Размеры проёма [5,4]

if check_brick_fit(*brick_size, *opening_size):
    print("Кирпич пролезет в проём.")
else:
    print("Кирпич не пролезет в проём.")
################################################################
# человек ждёт поезда которые приходят на 1-й платформе с интервалом a и стоят 1 мин на 2-й платформе интервал b и
# стоят 1 мин.
# на 1-й платформе челевек увидел n поездов на 2-й m поездов. Сколько максимально и минимально времени он стоял?
# min_a = a * (n - 1) + n  # +n - одна минута прежде чем увидел последний поезд
# аналогично
min_a = (a - 1) * (n - 1) + n  #
max_a = min_a + 2 * a  # 2*a - 2 поезда по краям в начале и в конце если он стоял всё время

min_b = (b - 1) * (n - 1) + n
max_b = min_b + 2 * b

min_time = max(min_a, min_b)
max_time = min(max_a, max_b)
if min_time > max_time:
    print(-1)
else:
    print(min_time, max_time)
################################################################
# В доме есть квартира к2 в подъезде р2 на этаже n2. В доме M этажей и количество квартир на каждой площадке одинаково.
# написать программу вычисляющую подъезд р2 и номер этажа n2 если известна квартира к1. числа до 10^6

M = int(input("Введите количество этажей в доме: "))  # Вводим количество этажей в доме
k1 = int(input("Введите номер квартиры k1: "))  # Вводим номер исходной квартиры k1

apartments_per_floor = k1 // M  # Количество квартир на каждом этаже

entrance = (k1 - 1) // (apartments_per_floor * M) + 1  # Вычисляем подъезд
floor = ((k1 - 1) // apartments_per_floor) % M + 1  # Вычисляем этаж

print(f"Подъезд: р{entrance}, Этаж: n{floor}")


################################################################
# Необходимо определить, является ли это слово палиндромом (одинаково читается вперед и назад, например, АННА).
# Палиндром — это когда строка или число одинаково читается в прямом и обратном направлении:
def polindrom(word):
    return 'Yes' if word == word[::-1] else 'No'


#
def polindrom(word):
    w = []
    for i in range(len(word) - 1, -1, -1):
        w.append(word[i])
    return w == word


#
def polindrom(word):
    for i in range(len(word) // 2):
        if word[i] != word[-i - 1]:
            return False
    return True


#
def polindrom(word):
    s1 = word[:len(word) // 2]
    s2 = word[(len(word) - len(word) // 2):]
    return s1 == ''.join(reversed(s2))


################################
# Дана последовательность чисел. Определить какое минимальное количество и каких чисел надо прописать в конец этой
# последовательности, чтобы она стала симметричной

# берём до той части строки которая является полиндромом
# ищет самую длинную суффиксную подпоследовательность, являющуюся палиндромом. Затем он добавляет до нее оставшиеся
# числа в обратном порядке в конец исходной последовательности. Этот алгоритм эффективно работает в случаях, когда у
# последовательности имеется большой палиндромический суффикс.
def make_symmetric(seq):
    for start in range(len(seq)):
        i = start
        j = len(seq) - 1
        while i < len(seq) and j >= 0 and seq[i] == seq[j] and i <= j:  # двигаемся навстречу пока вып-ся усл
            i += 1  # сдвигаем указатели
            j -= 1
        if i > j:  # i=5>3=j значит мы успешно прошли по полиндрому, полиндром между i и j, т.е. мы сдвигали i и j пока
            # выполнялось  условие seq[i] == seq[j] and i <= j..
            ans = []  # берём значения до start т.е. до той части строки которая явл. полиндромом
            for i in range(start - 1, -1, -1):  # range(start-1=4-1=  3,-1,-1) перебор инд-в с инд=3 до 0 в обратку
                ans.append(seq[i])
            return seq + ans  # [1 2 3 4 5] + [4 3 2 1]


seq = [1, 2, 3, 4, 5]

print(*make_symmetric(seq))  # 1 2 3 4 5 4 3 2 1
print(len(make_symmetric(seq)))


################################################################№№№№№
# 2. не всегда работает верно______
# полиндром = просто сравнивает элементы от начала и конца последовательности. При нахождении несоответствующих пар,
# он добавляет элемент с конца последовательности в ее конец. Это продолжается до середины списка. Однако второй
# алгоритм не является кошерным для задачи, поскольку он может добавлять числа в конец даже в том случае, когда это
# ненужно
def make_sequence_symmetric(sequence):
    n = len(sequence)
    i = 0
    while i < n // 2:
        if sequence[i] != sequence[n - i - 1]:
            sequence.append(sequence[n - i - 1])
        i += 1
    return sequence


seq = [1, 2, 3, 4, 5]
symmetric_seq = make_sequence_symmetric(seq)
print(symmetric_seq)
# Этот код определяет функцию make_sequence_symmetric, которая принимает последовательность чисел sequence и добавляет
# недостающие числа в конец последовательности, чтобы сделать ее симметричной. Функция проходит по первой половине
# последовательности и сравнивает элементы с их зеркальными отражениями. Если элементы не совпадают, то зеркальное
# отражение добавляется в конец последовательности.

################################################################
# В списке целых чисел найти три числа, произведение которых максимально
# сложностью O(n), вывести эти три числа
# 1. отсортировать. 2 варианта 1-произведение 3-х последних. либо произведение 2-х наименьших отрицательных на одно
# максимальное
l = [4, 5, 6, -1, -7, -9, 7]
l.sort()  # [-9, -7, -1, 4, 5, 6, 7]
if l[0] * l[1] * l[-1] > l[-1] * l[-2] * l[-3]:
    print(l[0] * l[1] * l[-1])  # if all numbers are negative
else:
    print(l[-1] * l[-2] * l[-3])  # 9*7*7=441
################################################################
# 2/
l = [4, 5, 6, -1, -7, -9, 7]


def find_max_product(numbers):
    if len(numbers) < 3:
        return None

    max1 = max2 = max3 = float('-inf')
    min1 = min2 = float('inf')

    for num in numbers:
        if num > max1:
            max3 = max2
            max2 = max1
            max1 = num
        elif num > max2:
            max3 = max2
            max2 = num
        elif num > max3:
            max3 = num

        if num < min1:
            min2 = min1
            min1 = num
        elif num < min2:
            min2 = num

    product1 = max1 * max2 * max3
    product2 = max1 * min1 * min2

    if product1 > product2:
        return max1, max2, max3
    else:
        return max1, min1, min2


numbers = [1, 2, 3, 4, 5]
result = find_max_product(l)
print(result)  # (7, -9, -7)


################################################################
# https://new.contest.yandex.ru/42734/problem?id=215/2022_11_08/wGEXsFgrcB
# Максимальное произведение
# Дана последовательность неотрицательных целых чисел
# Вычислите max произведение , числа должны быть разные
def max_pairwise_product(seq):
    max_1 = seq[0]
    max_2 = seq[1]
    if max_1 < max_2:
        max_1 = seq[1]
        max_2 = seq[0]

    for i in range(2, len(seq)):
        if max_1 < seq[i]:
            max_2 = max_1
            max_1 = seq[i]
        elif max_2 < seq[i]:
            max_2 = seq[i]

    return max_1 * max_2


if __name__ == '__main__':
    _ = int(input())
    input_numbers = list(map(int, input().split()))
    # seq = [1, 2, 3]
    print(max_pairwise_product(input_numbers))
# seq = [7, 5, 14, 2, 8, 8, 10, 1, 2, 3]
# print(max_num(seq))
################################
# 2.
n = int(input())
a = list(map(int, input().split()))

a.sort(reverse=True)
max_product = a[0] * a[1]
print(max_product)


################################
# Максимальное произведение — контрпример
# Рассмотрим псевдокод поиска двух максимальных элементов массива:Определите, можно ли построить такой пример
# входных данных, чтобы количество сравнений в алгоритме MaxPairwiseProduct было больше 1.5.Формат ввода
# Целое число n.Ограничения: 2≤n≤200000 Формат вывода В единственной строке выведите No, если подходящих входных
# данных не существует. Иначе в первой строке выведите Yes, а во второй строке �n чисел �1,�2,…,��a1,a2,…,an
# (0≤��≤2000000≤ai≤200000) — найденный контрпример.Если походящих последовательностей несколько, выведите любую из них.

def max_pairwise_product(seq):
    max_1, max_2 = seq[0], seq[1]
    c = 0
    if max_1 < max_2:
        max_1, max_2 = max_2, max_1
        c += 1

    for i in range(2, len(seq)):
        if max_1 < seq[i]:
            max_2 = max_1
            max_1 = seq[i]
            c += 2
        elif max_2 < seq[i]:
            max_2 = seq[i]
            c += 1
    return c
    # return max_1 * max_2


if __name__ == '__main__':
    n = int(input())
    seq = [i for i in range(1, n + 1)]
    count = max_pairwise_product(seq)
    seq.insert(0, seq.pop())
    if count > (1.5 * n):
        print('Yes')  # при n > 6 т.е. от 7....
        print(' '.join(str(i) for i in seq))
    else:
        print('No')


# Оценим количество сравнений в алгоритме. Количество сравнений в первом if-условии (m2 > m1) равно 1.
# Количество сравнений во втором if-условии (A[i] > m1) равно n-2. Количество сравнений внутри else-условия равно n-2.
# Итого количество сравнений равно 1 + (n-2) + (n-2) = 2n-3. Чтобы количество сравнений было больше 1.5n, необходимо
# выполнение неравенства 2n-3 > 1.5n. Решим это неравенство: 2n-3 > 1.5n 2n > 3
# n > 6 То есть, количество элементов массива должно быть больше 6.
########################################################################
##########################################################
# maximum prodact of 4 numbers
def max_product(nums):
    # Убедимся, что список чисел содержит по крайней мере 4 элемента
    if len(nums) < 4:
        return None

    # Отсортируем список в порядке возрастания
    nums.sort()

    # Максимальное произведение четырех чисел будет либо
    # произведение четырех самых больших чисел, либо
    # произведение двух наименьших чисел и двух самых больших чисел.
    return max(nums[0] * nums[1] * nums[2] * nums[3], nums[-1] * nums[-2] * nums[-3] * nums[-4],
               nums[0] * nums[1] * nums[-1] * nums[-2])


n = int(input())
l = list(map(int, input().split()))
print(max_product(l))


################################################################
# Дана последовательность положительных чисел длиной N и число x. найти два различных числа а и б из
# последовательности чтобы а+б=x или вернуть 0,0

def find_pair(nums, x):
    seen = set()  # Создаем set для хранения уже просмотренных чисел, set() чтобы числа были различные и не повторялись
    for a in nums:
        b = x - a  # Вычисляем разность между искомой суммой и текущим числом
        if b in seen:  # Если такая разность уже была просмотрена, то значит нашли пару чисел
            return a, b
        seen.add(a)  # Добавляем текущее число в множество просмотренных
    return 0, 0  # Если не найдено пару чисел, возвращаем (0, 0)


sequence = [1, 2, 3, 4, 5]
x = 6
a, b = find_pair(sequence, x)
print(a, b)


################################################################################################
def nums(nums, x):
    previous = set()
    for i in nums:
        if x - i in previous:
            return i, x - 1
        previous.add(i)
    return 0, 0


################################################################
# Дан словарь из N слов. длина каждого не превосходит K.
# В запаиси каждого из M слов текста(каждое длиний до K) может быть пропущена одна буква.
# Для каждого слова сказать входит ли оно (возможно с одной пропущенной буквой) в словарь
# 1/
def find_word(dictionary, text):
    word_set = set(dictionary)

    for word in text:
        for w_indx in range(len(word)):
            word_set.add(word[:w_indx] + word[w_indx + 1:])

    ans = []
    for word in text:
        ans.append(word in word_set)
    return ans


# 2/
def word_in_dictionary(dictionary, word):
    # Проверка, входит ли слово в словарь без пропущенной буквы
    if word in dictionary:
        return True

    # Проверка, входит ли слово в словарь с одной пропущенной буквой
    for i in range(len(word)):
        # Удаление i-й буквы из слова
        edited_word = word[:i] + word[i + 1:]
        if edited_word in dictionary:
            return True

    return False


def check_words_in_dictionary(dictionary, text):
    result = []
    for word in text:
        is_in_dictionary = word_in_dictionary(dictionary, word)
        result.append(is_in_dictionary)
    return result


dictionary = {'apple', 'banana', 'cherry', 'date'}
text = ['apple', 'banan', 'chery', 'data']
result = check_words_in_dictionary(dictionary, text)
print(result)  # [True, False, False, False]
################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################

################################################################
